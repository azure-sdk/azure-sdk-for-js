## API Report File for "@azure/arm-iotoperations"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public
export type ActionType = string;

// @public
export interface AdvancedSettings {
    clients?: ClientConfig;
    encryptInternalTraffic?: OperationalMode;
    internalCerts?: CertManagerCertOptions;
}

// @public
export interface AkriConnectorProperties {
    readonly provisioningState?: ProvisioningState;
}

// @public
export interface AkriConnectorResource extends ProxyResource {
    extendedLocation?: ExtendedLocation;
    properties?: AkriConnectorProperties;
}

// @public
export interface AkriConnectorsContainerRegistry extends AkriConnectorsRegistrySettings {
    containerRegistrySettings: AkriConnectorsContainerRegistrySettings;
    registrySettingsType: "ContainerRegistry";
}

// @public
export interface AkriConnectorsContainerRegistrySettings {
    imagePullSecrets?: AkriConnectorsImagePullSecret[];
    registry: string;
}

// @public
export interface AkriConnectorsDiagnosticsLogs {
    level?: string;
}

// @public
export interface AkriConnectorsDigest extends AkriConnectorsTagDigestSettings {
    digest: string;
    tagDigestType: "Digest";
}

// @public
export type AkriConnectorsImagePullPolicy = string;

// @public
export interface AkriConnectorsImagePullSecret {
    secretRef: string;
}

// @public
export interface AkriConnectorsMqttAuthentication {
    method: AkriConnectorsMqttAuthenticationMethod;
}

// @public
export type AkriConnectorsMqttAuthenticationMethod = string;

// @public
export type AkriConnectorsMqttAuthenticationUnion = AkriConnectorsServiceAccountAuthentication | AkriConnectorsMqttAuthentication;

// @public
export interface AkriConnectorsMqttConnectionConfiguration {
    authentication?: AkriConnectorsMqttAuthenticationUnion;
    host?: string;
    keepAliveSeconds?: number;
    maxInflightMessages?: number;
    protocol?: AkriConnectorsMqttProtocolType;
    sessionExpirySeconds?: number;
    tls?: TlsProperties;
}

// @public
export type AkriConnectorsMqttProtocolType = string;

// @public
export interface AkriConnectorsRegistryEndpointRef extends AkriConnectorsRegistrySettings {
    registryEndpointRef: string;
    registrySettingsType: "RegistryEndpointRef";
}

// @public
export interface AkriConnectorsRegistrySettings {
    // (undocumented)
    registrySettingsType: AkriConnectorsRegistrySettingsType;
}

// @public
export type AkriConnectorsRegistrySettingsType = string;

// @public
export type AkriConnectorsRegistrySettingsUnion = AkriConnectorsRegistryEndpointRef | AkriConnectorsContainerRegistry | AkriConnectorsRegistrySettings;

// @public
export interface AkriConnectorsSecret {
    secretAlias: string;
    secretKey: string;
    secretRef: string;
}

// @public
export interface AkriConnectorsServiceAccountAuthentication extends AkriConnectorsMqttAuthentication {
    method: "ServiceAccountToken";
    serviceAccountTokenSettings: AkriConnectorsServiceAccountTokenSettings;
}

// @public
export interface AkriConnectorsServiceAccountTokenSettings {
    audience: string;
}

// @public
export interface AkriConnectorsTag extends AkriConnectorsTagDigestSettings {
    tag: string;
    tagDigestType: "Tag";
}

// @public
export interface AkriConnectorsTagDigestSettings {
    tagDigestType: AkriConnectorsTagDigestType;
}

// @public
export type AkriConnectorsTagDigestSettingsUnion = AkriConnectorsTag | AkriConnectorsDigest | AkriConnectorsTagDigestSettings;

// @public
export type AkriConnectorsTagDigestType = string;

// @public
export interface AkriConnectorTemplateAioMetadata {
    aioMaxVersion?: string;
    aioMinVersion?: string;
}

// @public
export interface AkriConnectorTemplateAllocation {
    policy: AkriConnectorTemplateAllocationPolicy;
}

// @public
export type AkriConnectorTemplateAllocationPolicy = string;

// @public
export type AkriConnectorTemplateAllocationUnion = AkriConnectorTemplateBucketizedAllocation | AkriConnectorTemplateAllocation;

// @public
export interface AkriConnectorTemplateBucketizedAllocation extends AkriConnectorTemplateAllocation {
    bucketSize: number;
    policy: "Bucketized";
}

// @public
export interface AkriConnectorTemplateDeviceInboundEndpointConfigurationSchemaRefs {
    additionalConfigSchemaRef?: string;
    defaultDatasetConfigSchemaRef?: string;
    defaultEventsConfigSchemaRef?: string;
    defaultProcessControlConfigSchemaRef?: string;
    defaultStreamsConfigSchemaRef?: string;
}

// @public
export interface AkriConnectorTemplateDeviceInboundEndpointType {
    configurationSchemaRefs?: AkriConnectorTemplateDeviceInboundEndpointConfigurationSchemaRefs;
    endpointType: string;
    version: string;
}

// @public
export interface AkriConnectorTemplateDiagnostics {
    logs: AkriConnectorsDiagnosticsLogs;
}

// @public
export interface AkriConnectorTemplateHelmAdvancedConfiguration {
    delete?: AkriConnectorTemplateHelmDeleteConfiguration;
    install?: AkriConnectorTemplateHelmInstallConfiguration;
    upgrade?: AkriConnectorTemplateHelmUpgradeConfiguration;
}

// @public
export interface AkriConnectorTemplateHelmAuthSecretRef {
    passwordKey: string;
    secretRef: string;
    usernameKey: string;
}

// @public
export interface AkriConnectorTemplateHelmConfiguration extends AkriConnectorTemplateRuntimeConfiguration {
    helmConfigurationSettings: AkriConnectorTemplateHelmConfigurationSettings;
    runtimeConfigurationType: "HelmConfiguration";
}

// @public
export interface AkriConnectorTemplateHelmConfigurationSettings {
    advancedConfiguration?: AkriConnectorTemplateHelmAdvancedConfiguration;
    registrySettings?: AkriConnectorTemplateHelmRegistrySettingsUnion;
    releaseName: string;
    values?: Record<string, string>;
    version: string;
}

// @public
export interface AkriConnectorTemplateHelmContainerRegistry extends AkriConnectorTemplateHelmRegistrySettings {
    containerRegistrySettings: AkriConnectorTemplateHelmContainerRegistrySettings;
    registrySettingsType: "ContainerRegistry";
}

// @public
export interface AkriConnectorTemplateHelmContainerRegistrySettings {
    authSecretRef?: AkriConnectorTemplateHelmAuthSecretRef;
    registry: string;
    repository: string;
}

// @public
export interface AkriConnectorTemplateHelmDeleteConfiguration {
    atomic?: boolean;
    disableHooks?: boolean;
    timeout?: number;
    wait?: boolean;
    waitForJobs?: boolean;
}

// @public
export interface AkriConnectorTemplateHelmInstallConfiguration {
    atomic?: boolean;
    disableHooks?: boolean;
    timeout?: number;
    wait?: boolean;
    waitForJobs?: boolean;
}

// @public
export interface AkriConnectorTemplateHelmRegistryEndpointRef extends AkriConnectorTemplateHelmRegistrySettings {
    registryEndpointRef: string;
    registrySettingsType: "RegistryEndpointRef";
}

// @public
export interface AkriConnectorTemplateHelmRegistrySettings {
    // (undocumented)
    registrySettingsType: AkriConnectorTemplateHelmRegistrySettingsType;
}

// @public
export type AkriConnectorTemplateHelmRegistrySettingsType = string;

// @public
export type AkriConnectorTemplateHelmRegistrySettingsUnion = AkriConnectorTemplateHelmRegistryEndpointRef | AkriConnectorTemplateHelmContainerRegistry | AkriConnectorTemplateHelmRegistrySettings;

// @public
export interface AkriConnectorTemplateHelmUpgradeConfiguration {
    atomic?: boolean;
    disableHooks?: boolean;
    timeout?: number;
    wait?: boolean;
    waitForJobs?: boolean;
}

// @public
export interface AkriConnectorTemplateManagedConfiguration extends AkriConnectorTemplateRuntimeConfiguration {
    managedConfigurationSettings: AkriConnectorTemplateManagedConfigurationSettingsUnion;
    runtimeConfigurationType: "ManagedConfiguration";
}

// @public
export interface AkriConnectorTemplateManagedConfigurationSettings {
    additionalConfiguration?: Record<string, string>;
    allocation?: AkriConnectorTemplateAllocationUnion;
    managedConfigurationType: AkriConnectorTemplateManagedConfigurationType;
    persistentVolumeClaims?: AkriConnectorTemplatePersistentVolumeClaim[];
    persistentVolumeClaimTemplates?: Record<string, any>[];
    secrets?: AkriConnectorsSecret[];
    trustSettings?: AkriConnectorTemplateTrustList;
}

// @public
export type AkriConnectorTemplateManagedConfigurationSettingsUnion = AkriConnectorTemplateRuntimeImageConfiguration | AkriConnectorTemplateRuntimeStatefulSetConfiguration | AkriConnectorTemplateManagedConfigurationSettings;

// @public
export type AkriConnectorTemplateManagedConfigurationType = string;

// @public
export interface AkriConnectorTemplatePersistentVolumeClaim {
    claimName: string;
    mountPath: string;
}

// @public
export interface AkriConnectorTemplateProperties {
    aioMetadata?: AkriConnectorTemplateAioMetadata;
    deviceInboundEndpointTypes: AkriConnectorTemplateDeviceInboundEndpointType[];
    diagnostics?: AkriConnectorTemplateDiagnostics;
    mqttConnectionConfiguration?: AkriConnectorsMqttConnectionConfiguration;
    readonly provisioningState?: ProvisioningState;
    runtimeConfiguration: AkriConnectorTemplateRuntimeConfigurationUnion;
}

// @public
export interface AkriConnectorTemplateResource extends ProxyResource {
    extendedLocation?: ExtendedLocation;
    properties?: AkriConnectorTemplateProperties;
}

// @public
export interface AkriConnectorTemplateRuntimeConfiguration {
    runtimeConfigurationType: AkriConnectorTemplateRuntimeConfigurationType;
}

// @public
export type AkriConnectorTemplateRuntimeConfigurationType = string;

// @public
export type AkriConnectorTemplateRuntimeConfigurationUnion = AkriConnectorTemplateHelmConfiguration | AkriConnectorTemplateManagedConfiguration | AkriConnectorTemplateRuntimeConfiguration;

// @public
export interface AkriConnectorTemplateRuntimeImageConfiguration extends AkriConnectorTemplateManagedConfigurationSettings {
    imageConfigurationSettings: AkriConnectorTemplateRuntimeImageConfigurationSettings;
    managedConfigurationType: "ImageConfiguration";
}

// @public
export interface AkriConnectorTemplateRuntimeImageConfigurationSettings {
    imageName: string;
    imagePullPolicy?: AkriConnectorsImagePullPolicy;
    registrySettings?: AkriConnectorsRegistrySettingsUnion;
    replicas?: number;
    tagDigestSettings?: AkriConnectorsTagDigestSettingsUnion;
}

// @public
export interface AkriConnectorTemplateRuntimeStatefulSetConfiguration extends AkriConnectorTemplateManagedConfigurationSettings {
    managedConfigurationType: "StatefulSetConfiguration";
    statefulSetConfigurationSettings: Record<string, any>;
}

// @public
export interface AkriConnectorTemplateTrustList {
    trustListSecretRef: string;
}

// @public
export interface AkriDiscoveryHandlerAioMetadata {
    aioMaxVersion?: string;
    aioMinVersion?: string;
}

// @public
export interface AkriDiscoveryHandlerDiagnostics {
    logs: AkriConnectorsDiagnosticsLogs;
}

// @public
export interface AkriDiscoveryHandlerDiscoverableDeviceEndpointType {
    endpointType: string;
    version: string;
}

// @public
export interface AkriDiscoveryHandlerImageConfiguration {
    imageName: string;
    imagePullPolicy?: AkriConnectorsImagePullPolicy;
    registrySettings?: AkriConnectorsRegistrySettingsUnion;
    replicas?: number;
    tagDigestSettings?: AkriConnectorsTagDigestSettingsUnion;
}

// @public
export interface AkriDiscoveryHandlerProperties {
    additionalConfiguration?: Record<string, string>;
    aioMetadata?: AkriDiscoveryHandlerAioMetadata;
    diagnostics?: AkriDiscoveryHandlerDiagnostics;
    discoverableDeviceEndpointTypes: AkriDiscoveryHandlerDiscoverableDeviceEndpointType[];
    imageConfiguration: AkriDiscoveryHandlerImageConfiguration;
    mode?: OperationalMode;
    mqttConnectionConfiguration?: AkriConnectorsMqttConnectionConfiguration;
    readonly provisioningState?: ProvisioningState;
    schedule: AkriDiscoveryHandlerScheduleUnion;
    secrets?: AkriConnectorsSecret[];
}

// @public
export interface AkriDiscoveryHandlerResource extends ProxyResource {
    extendedLocation?: ExtendedLocation;
    properties?: AkriDiscoveryHandlerProperties;
}

// @public
export interface AkriDiscoveryHandlerSchedule {
    scheduleType: AkriDiscoveryHandlerScheduleType;
}

// @public
export interface AkriDiscoveryHandlerScheduleContinuous extends AkriDiscoveryHandlerSchedule {
    continuous: string;
    scheduleType: "Continuous";
}

// @public
export interface AkriDiscoveryHandlerScheduleCron extends AkriDiscoveryHandlerSchedule {
    cron: string;
    scheduleType: "Cron";
}

// @public
export interface AkriDiscoveryHandlerScheduleRunOnce extends AkriDiscoveryHandlerSchedule {
    runOnce: string;
    scheduleType: "RunOnce";
}

// @public
export type AkriDiscoveryHandlerScheduleType = string;

// @public
export type AkriDiscoveryHandlerScheduleUnion = AkriDiscoveryHandlerScheduleCron | AkriDiscoveryHandlerScheduleRunOnce | AkriDiscoveryHandlerScheduleContinuous | AkriDiscoveryHandlerSchedule;

// @public
export interface AuthorizationConfig {
    cache?: OperationalMode;
    rules?: AuthorizationRule[];
}

// @public
export interface AuthorizationRule {
    brokerResources: BrokerResourceRule[];
    principals: PrincipalDefinition;
    stateStoreResources?: StateStoreResourceRule[];
}

// @public
export interface AzureDeviceRegistryNamespaceRef {
    resourceId: string;
}

// @public
export interface BackendChain {
    partitions: number;
    redundancyFactor: number;
    workers?: number;
}

// @public
export interface BatchingConfiguration {
    latencySeconds?: number;
    maxMessages?: number;
}

// @public
export type BrokerAuthenticationMethod = string;

// @public
export interface BrokerAuthenticationProperties {
    authenticationMethods: BrokerAuthenticatorMethods[];
    readonly provisioningState?: ProvisioningState;
}

// @public
export interface BrokerAuthenticationResource extends ProxyResource {
    extendedLocation?: ExtendedLocation;
    properties?: BrokerAuthenticationProperties;
}

// @public
export interface BrokerAuthenticatorCustomAuth {
    x509: X509ManualCertificate;
}

// @public
export interface BrokerAuthenticatorMethodCustom {
    auth?: BrokerAuthenticatorCustomAuth;
    caCertConfigMap?: string;
    endpoint: string;
    headers?: Record<string, string>;
}

// @public
export interface BrokerAuthenticatorMethods {
    customSettings?: BrokerAuthenticatorMethodCustom;
    method: BrokerAuthenticationMethod;
    serviceAccountTokenSettings?: BrokerAuthenticatorMethodSat;
    x509Settings?: BrokerAuthenticatorMethodX509;
}

// @public
export interface BrokerAuthenticatorMethodSat {
    audiences: string[];
}

// @public
export interface BrokerAuthenticatorMethodX509 {
    additionalValidation?: BrokerAuthenticatorValidationMethods;
    authorizationAttributes?: Record<string, BrokerAuthenticatorMethodX509Attributes>;
    trustedClientCaCert?: string;
}

// @public
export interface BrokerAuthenticatorMethodX509Attributes {
    attributes: Record<string, string>;
    subject: string;
}

// @public
export type BrokerAuthenticatorValidationMethods = string;

// @public
export interface BrokerAuthorizationProperties {
    authorizationPolicies: AuthorizationConfig;
    readonly provisioningState?: ProvisioningState;
}

// @public
export interface BrokerAuthorizationResource extends ProxyResource {
    extendedLocation?: ExtendedLocation;
    properties?: BrokerAuthorizationProperties;
}

// @public
export interface BrokerDiagnostics {
    logs?: DiagnosticsLogs;
    metrics?: Metrics;
    selfCheck?: SelfCheck;
    traces?: Traces;
}

// @public
export interface BrokerListenerProperties {
    ports: ListenerPort[];
    readonly provisioningState?: ProvisioningState;
    serviceName?: string;
    serviceType?: ServiceType;
}

// @public
export interface BrokerListenerResource extends ProxyResource {
    extendedLocation?: ExtendedLocation;
    properties?: BrokerListenerProperties;
}

// @public
export type BrokerMemoryProfile = string;

// @public
export interface BrokerPersistence {
    dynamicSettings?: BrokerPersistenceDynamicSettings;
    encryption?: BrokerPersistenceEncryption;
    maxSize: string;
    persistentVolumeClaimSpec?: VolumeClaimSpec;
    retain?: BrokerRetainMessagesPolicyUnion;
    stateStore?: BrokerStateStorePolicyUnion;
    subscriberQueue?: BrokerSubscriberQueuePolicyUnion;
}

// @public
export interface BrokerPersistenceDynamicSettings {
    userPropertyKey: string;
    userPropertyValue: string;
}

// @public
export interface BrokerPersistenceEncryption {
    mode: OperationalMode;
}

// @public
export type BrokerPersistencePolicyMode = string;

// @public
export interface BrokerProperties {
    advanced?: AdvancedSettings;
    cardinality?: Cardinality;
    diagnostics?: BrokerDiagnostics;
    diskBackedMessageBuffer?: DiskBackedMessageBuffer;
    generateResourceLimits?: GenerateResourceLimits;
    memoryProfile?: BrokerMemoryProfile;
    persistence?: BrokerPersistence;
    readonly provisioningState?: ProvisioningState;
}

// @public
export type BrokerProtocolType = string;

// @public
export interface BrokerResource extends ProxyResource {
    extendedLocation?: ExtendedLocation;
    properties?: BrokerProperties;
}

// @public
export type BrokerResourceDefinitionMethods = string;

// @public
export interface BrokerResourceRule {
    clientIds?: string[];
    method: BrokerResourceDefinitionMethods;
    topics?: string[];
}

// @public
export interface BrokerRetainMessagesCustomPolicy extends BrokerRetainMessagesPolicy {
    mode: "Custom";
    retainSettings: BrokerRetainMessagesSettings;
}

// @public
export interface BrokerRetainMessagesDynamic {
    mode: OperationalMode;
}

// @public
export interface BrokerRetainMessagesPolicy {
    mode: BrokerPersistencePolicyMode;
}

// @public
export type BrokerRetainMessagesPolicyUnion = BrokerRetainMessagesCustomPolicy | BrokerRetainMessagesPolicy;

// @public
export interface BrokerRetainMessagesSettings {
    dynamic?: BrokerRetainMessagesDynamic;
    topics?: string[];
}

// @public
export interface BrokerStateStoreCustomPolicy extends BrokerStateStorePolicy {
    mode: "Custom";
    stateStoreSettings: BrokerStateStorePolicySettings;
}

// @public
export interface BrokerStateStoreDynamic {
    mode: OperationalMode;
}

// @public
export type BrokerStateStoreKeyType = string;

// @public
export interface BrokerStateStorePolicy {
    mode: BrokerPersistencePolicyMode;
}

// @public
export interface BrokerStateStorePolicyResources {
    keys: string[];
    keyType: BrokerStateStoreKeyType;
}

// @public
export interface BrokerStateStorePolicySettings {
    dynamic?: BrokerStateStoreDynamic;
    stateStoreResources?: BrokerStateStorePolicyResources[];
}

// @public
export type BrokerStateStorePolicyUnion = BrokerStateStoreCustomPolicy | BrokerStateStorePolicy;

// @public
export interface BrokerSubscriberQueueCustomPolicy extends BrokerSubscriberQueuePolicy {
    mode: "Custom";
    subscriberQueueSettings: BrokerSubscriberQueueCustomPolicySettings;
}

// @public
export interface BrokerSubscriberQueueCustomPolicySettings {
    dynamic?: BrokerSubscriberQueueDynamic;
    subscriberClientIds?: string[];
    topics?: string[];
}

// @public
export interface BrokerSubscriberQueueDynamic {
    mode: OperationalMode;
}

// @public
export interface BrokerSubscriberQueuePolicy {
    mode: BrokerPersistencePolicyMode;
}

// @public
export type BrokerSubscriberQueuePolicyUnion = BrokerSubscriberQueueCustomPolicy | BrokerSubscriberQueuePolicy;

// @public
export interface Cardinality {
    backendChain: BackendChain;
    frontend: Frontend;
}

// @public
export interface CertManagerCertificateSpec {
    duration?: string;
    issuerRef: CertManagerIssuerRef;
    privateKey?: CertManagerPrivateKey;
    renewBefore?: string;
    san?: SanForCert;
    secretName?: string;
}

// @public
export interface CertManagerCertOptions {
    duration: string;
    privateKey: CertManagerPrivateKey;
    renewBefore: string;
}

// @public
export type CertManagerIssuerKind = string;

// @public
export interface CertManagerIssuerRef {
    group: string;
    kind: CertManagerIssuerKind;
    name: string;
}

// @public
export interface CertManagerPrivateKey {
    algorithm: PrivateKeyAlgorithm;
    rotationPolicy: PrivateKeyRotationPolicy;
}

// @public
export interface ClientConfig {
    maxKeepAliveSeconds?: number;
    maxMessageExpirySeconds?: number;
    maxPacketSizeBytes?: number;
    maxReceiveMaximum?: number;
    maxSessionExpirySeconds?: number;
    subscriberQueueLimit?: SubscriberQueueLimit;
}

// @public
export type CloudEventAttributeType = string;

// @public
export type CreatedByType = string;

// @public
export type DataExplorerAuthMethod = string;

// @public
export interface DatafloGraphDestinationNode extends DataflowGraphNode {
    destinationSettings: DataflowGraphDestinationNodeSettings;
    type: "Destination";
}

// @public
export interface DataflowBuiltInTransformationDataset {
    description?: string;
    expression?: string;
    inputs: string[];
    key: string;
    schemaRef?: string;
}

// @public
export interface DataflowBuiltInTransformationFilter {
    description?: string;
    expression: string;
    inputs: string[];
    type?: FilterType;
}

// @public
export interface DataflowBuiltInTransformationMap {
    description?: string;
    expression?: string;
    inputs: string[];
    output: string;
    type?: DataflowMappingType;
}

// @public
export interface DataflowBuiltInTransformationSettings {
    datasets?: DataflowBuiltInTransformationDataset[];
    filter?: DataflowBuiltInTransformationFilter[];
    map?: DataflowBuiltInTransformationMap[];
    schemaRef?: string;
    serializationFormat?: TransformationSerializationFormat;
}

// @public
export interface DataflowDestinationOperationSettings {
    dataDestination: string;
    endpointRef: string;
}

// @public
export interface DataflowEndpointAuthenticationAccessToken {
    secretRef: string;
}

// @public
export interface DataflowEndpointAuthenticationAnonymous {
}

// @public
export interface DataflowEndpointAuthenticationSasl {
    saslType: DataflowEndpointAuthenticationSaslType;
    secretRef: string;
}

// @public
export type DataflowEndpointAuthenticationSaslType = string;

// @public
export interface DataflowEndpointAuthenticationServiceAccountToken {
    audience: string;
}

// @public
export interface DataflowEndpointAuthenticationSystemAssignedManagedIdentity {
    audience?: string;
}

// @public
export interface DataflowEndpointAuthenticationUserAssignedManagedIdentity {
    clientId: string;
    scope?: string;
    tenantId: string;
}

// @public
export interface DataflowEndpointAuthenticationX509 {
    secretRef: string;
}

// @public
export interface DataflowEndpointDataExplorer {
    authentication: DataflowEndpointDataExplorerAuthentication;
    batching?: BatchingConfiguration;
    database: string;
    host: string;
}

// @public
export interface DataflowEndpointDataExplorerAuthentication {
    method: DataExplorerAuthMethod;
    systemAssignedManagedIdentitySettings?: DataflowEndpointAuthenticationSystemAssignedManagedIdentity;
    userAssignedManagedIdentitySettings?: DataflowEndpointAuthenticationUserAssignedManagedIdentity;
}

// @public
export interface DataflowEndpointDataLakeStorage {
    authentication: DataflowEndpointDataLakeStorageAuthentication;
    batching?: BatchingConfiguration;
    host: string;
}

// @public
export interface DataflowEndpointDataLakeStorageAuthentication {
    accessTokenSettings?: DataflowEndpointAuthenticationAccessToken;
    method: DataLakeStorageAuthMethod;
    systemAssignedManagedIdentitySettings?: DataflowEndpointAuthenticationSystemAssignedManagedIdentity;
    userAssignedManagedIdentitySettings?: DataflowEndpointAuthenticationUserAssignedManagedIdentity;
}

// @public
export interface DataflowEndpointFabricOneLake {
    authentication: DataflowEndpointFabricOneLakeAuthentication;
    batching?: BatchingConfiguration;
    host: string;
    names: DataflowEndpointFabricOneLakeNames;
    oneLakePathType: DataflowEndpointFabricPathType;
}

// @public
export interface DataflowEndpointFabricOneLakeAuthentication {
    method: FabricOneLakeAuthMethod;
    systemAssignedManagedIdentitySettings?: DataflowEndpointAuthenticationSystemAssignedManagedIdentity;
    userAssignedManagedIdentitySettings?: DataflowEndpointAuthenticationUserAssignedManagedIdentity;
}

// @public
export interface DataflowEndpointFabricOneLakeNames {
    lakehouseName: string;
    workspaceName: string;
}

// @public
export type DataflowEndpointFabricPathType = string;

// @public
export interface DataflowEndpointKafka {
    authentication: DataflowEndpointKafkaAuthentication;
    batching?: DataflowEndpointKafkaBatching;
    cloudEventAttributes?: CloudEventAttributeType;
    compression?: DataflowEndpointKafkaCompression;
    consumerGroupId?: string;
    copyMqttProperties?: OperationalMode;
    host: string;
    kafkaAcks?: DataflowEndpointKafkaAcks;
    partitionStrategy?: DataflowEndpointKafkaPartitionStrategy;
    tls?: TlsProperties;
}

// @public
export type DataflowEndpointKafkaAcks = string;

// @public
export interface DataflowEndpointKafkaAuthentication {
    method: KafkaAuthMethod;
    saslSettings?: DataflowEndpointAuthenticationSasl;
    systemAssignedManagedIdentitySettings?: DataflowEndpointAuthenticationSystemAssignedManagedIdentity;
    userAssignedManagedIdentitySettings?: DataflowEndpointAuthenticationUserAssignedManagedIdentity;
    x509CertificateSettings?: DataflowEndpointAuthenticationX509;
}

// @public
export interface DataflowEndpointKafkaBatching {
    latencyMs?: number;
    maxBytes?: number;
    maxMessages?: number;
    mode?: OperationalMode;
}

// @public
export type DataflowEndpointKafkaCompression = string;

// @public
export type DataflowEndpointKafkaPartitionStrategy = string;

// @public
export interface DataflowEndpointLocalStorage {
    persistentVolumeClaimRef: string;
}

// @public
export interface DataflowEndpointMqtt {
    authentication: DataflowEndpointMqttAuthentication;
    clientIdPrefix?: string;
    cloudEventAttributes?: CloudEventAttributeType;
    host?: string;
    keepAliveSeconds?: number;
    maxInflightMessages?: number;
    protocol?: BrokerProtocolType;
    qos?: number;
    retain?: MqttRetainType;
    sessionExpirySeconds?: number;
    tls?: TlsProperties;
}

// @public
export interface DataflowEndpointMqttAuthentication {
    method: MqttAuthMethod;
    serviceAccountTokenSettings?: DataflowEndpointAuthenticationServiceAccountToken;
    systemAssignedManagedIdentitySettings?: DataflowEndpointAuthenticationSystemAssignedManagedIdentity;
    userAssignedManagedIdentitySettings?: DataflowEndpointAuthenticationUserAssignedManagedIdentity;
    x509CertificateSettings?: DataflowEndpointAuthenticationX509;
}

// @public
export interface DataflowEndpointOpenTelemetry {
    authentication: DataflowOpenTelemetryAuthenticationUnion;
    batching?: BatchingConfiguration;
    host: string;
    tls?: TlsProperties;
}

// @public
export interface DataflowEndpointProperties {
    dataExplorerSettings?: DataflowEndpointDataExplorer;
    dataLakeStorageSettings?: DataflowEndpointDataLakeStorage;
    endpointType: EndpointType;
    fabricOneLakeSettings?: DataflowEndpointFabricOneLake;
    hostType?: DataflowEnpointHostType;
    kafkaSettings?: DataflowEndpointKafka;
    localStorageSettings?: DataflowEndpointLocalStorage;
    mqttSettings?: DataflowEndpointMqtt;
    openTelemetrySettings?: DataflowEndpointOpenTelemetry;
    readonly provisioningState?: ProvisioningState;
}

// @public
export interface DataflowEndpointResource extends ProxyResource {
    extendedLocation?: ExtendedLocation;
    properties?: DataflowEndpointProperties;
}

// @public
export type DataflowEnpointHostType = string;

// @public
export interface DataflowGraphConnectionInput {
    name: string;
    schema?: DataflowGraphSchemaSettings;
}

// @public
export interface DataflowGraphConnectionOutput {
    name: string;
}

// @public
export interface DataflowGraphDestinationNodeSettings {
    dataDestination: string;
    endpointRef: string;
    outputSchemaSettings?: DataflowGraphSchemaSettings;
}

// @public
export interface DataflowGraphGraphNode extends DataflowGraphNode {
    graphSettings: DataflowGraphNodeGraphSettings;
    type: "Graph";
}

// @public
export interface DataflowGraphGraphNodeConfiguration {
    key: string;
    value: string;
}

// @public
export interface DataflowGraphNode {
    name: string;
    type: DataflowGraphNodeType;
}

// @public
export interface DataflowGraphNodeConnection {
    from: DataflowGraphConnectionInput;
    to: DataflowGraphConnectionOutput;
}

// @public
export interface DataflowGraphNodeGraphSettings {
    artifact: string;
    configuration?: DataflowGraphGraphNodeConfiguration[];
    registryEndpointRef: string;
}

// @public
export type DataflowGraphNodeType = string;

// @public
export type DataflowGraphNodeUnion = DataflowGraphSourceNode | DataflowGraphGraphNode | DatafloGraphDestinationNode | DataflowGraphNode;

// @public
export interface DataflowGraphProperties {
    mode?: OperationalMode;
    nodeConnections: DataflowGraphNodeConnection[];
    nodes: DataflowGraphNodeUnion[];
    readonly provisioningState?: ProvisioningState;
    requestDiskPersistence?: OperationalMode;
}

// @public
export interface DataflowGraphResource extends ProxyResource {
    extendedLocation?: ExtendedLocation;
    properties?: DataflowGraphProperties;
}

// @public
export interface DataflowGraphSchemaSettings {
    schemaRef: string;
    serializationFormat?: DataflowGraphSerializationFormat;
}

// @public
export type DataflowGraphSerializationFormat = string;

// @public
export interface DataflowGraphSourceNode extends DataflowGraphNode {
    sourceSettings: DataflowGraphSourceSettings;
    type: "Source";
}

// @public
export interface DataflowGraphSourceSettings {
    dataSources: string[];
    endpointRef: string;
}

// @public
export type DataflowMappingType = string;

// @public
export interface DataflowOpenTelemetryAnonymousAuthentication extends DataflowOpenTelemetryAuthentication {
    anonymousSettings: DataflowEndpointAuthenticationAnonymous;
    method: "Anonymous";
}

// @public
export interface DataflowOpenTelemetryAuthentication {
    method: DataflowOpenTelemetryAuthenticationMethod;
}

// @public
export type DataflowOpenTelemetryAuthenticationMethod = string;

// @public
export type DataflowOpenTelemetryAuthenticationUnion = DataflowOpenTelemetryServiceAccountAuthentication | DataflowOpenTelemetryX509CertificateAuthentication | DataflowOpenTelemetryAnonymousAuthentication | DataflowOpenTelemetryAuthentication;

// @public
export interface DataflowOpenTelemetryServiceAccountAuthentication extends DataflowOpenTelemetryAuthentication {
    method: "ServiceAccountToken";
    serviceAccountTokenSettings: DataflowEndpointAuthenticationServiceAccountToken;
}

// @public
export interface DataflowOpenTelemetryX509CertificateAuthentication extends DataflowOpenTelemetryAuthentication {
    method: "X509Certificate";
    x509CertificateSettings: DataflowEndpointAuthenticationX509;
}

// @public
export interface DataflowOperation {
    builtInTransformationSettings?: DataflowBuiltInTransformationSettings;
    destinationSettings?: DataflowDestinationOperationSettings;
    name?: string;
    operationType: OperationType;
    sourceSettings?: DataflowSourceOperationSettings;
}

// @public
export interface DataflowProfileProperties {
    diagnostics?: ProfileDiagnostics;
    instanceCount?: number;
    readonly provisioningState?: ProvisioningState;
}

// @public
export interface DataflowProfileResource extends ProxyResource {
    extendedLocation?: ExtendedLocation;
    properties?: DataflowProfileProperties;
}

// @public
export interface DataflowProperties {
    mode?: OperationalMode;
    operations: DataflowOperation[];
    readonly provisioningState?: ProvisioningState;
}

// @public
export interface DataflowResource extends ProxyResource {
    extendedLocation?: ExtendedLocation;
    properties?: DataflowProperties;
}

// @public
export interface DataflowSourceOperationSettings {
    assetRef?: string;
    dataSources: string[];
    endpointRef: string;
    schemaRef?: string;
    serializationFormat?: SourceSerializationFormat;
}

// @public
export type DataLakeStorageAuthMethod = string;

// @public
export interface DiagnosticsLogs {
    level?: string;
}

// @public
export interface DiskBackedMessageBuffer {
    ephemeralVolumeClaimSpec?: VolumeClaimSpec;
    maxSize: string;
    persistentVolumeClaimSpec?: VolumeClaimSpec;
}

// @public
export type EndpointType = string;

// @public
export interface ErrorAdditionalInfo {
    readonly info?: Record<string, any>;
    readonly type?: string;
}

// @public
export interface ErrorDetail {
    readonly additionalInfo?: ErrorAdditionalInfo[];
    readonly code?: string;
    readonly details?: ErrorDetail[];
    readonly message?: string;
    readonly target?: string;
}

// @public
export interface ErrorResponse {
    error?: ErrorDetail;
}

// @public
export interface ExtendedLocation {
    name: string;
    type: ExtendedLocationType;
}

// @public
export type ExtendedLocationType = string;

// @public
export type FabricOneLakeAuthMethod = string;

// @public
export type FilterType = string;

// @public
export interface Frontend {
    replicas: number;
    workers?: number;
}

// @public
export interface GenerateResourceLimits {
    cpu?: OperationalMode;
}

// @public
export interface InstanceFeature {
    mode?: InstanceFeatureMode;
    settings?: Record<string, OperationalMode>;
}

// @public
export type InstanceFeatureMode = string;

// @public
export interface InstancePatchModel {
    identity?: ManagedServiceIdentity;
    tags?: Record<string, string>;
}

// @public
export interface InstanceProperties {
    adrNamespaceRef?: AzureDeviceRegistryNamespaceRef;
    defaultSecretProviderClassRef?: SecretProviderClassRef;
    description?: string;
    features?: Record<string, InstanceFeature>;
    readonly provisioningState?: ProvisioningState;
    schemaRegistryRef: SchemaRegistryRef;
    readonly version?: string;
}

// @public
export interface InstanceResource extends TrackedResource {
    extendedLocation: ExtendedLocation;
    identity?: ManagedServiceIdentity;
    properties?: InstanceProperties;
}

// @public
export type KafkaAuthMethod = string;

// @public
export enum KnownActionType {
    Internal = "Internal"
}

// @public
export enum KnownAkriConnectorsImagePullPolicy {
    Always = "Always",
    IfNotPresent = "IfNotPresent",
    Never = "Never"
}

// @public
export enum KnownAkriConnectorsMqttAuthenticationMethod {
    ServiceAccountToken = "ServiceAccountToken"
}

// @public
export enum KnownAkriConnectorsMqttProtocolType {
    Mqtt = "Mqtt"
}

// @public
export enum KnownAkriConnectorsRegistrySettingsType {
    ContainerRegistry = "ContainerRegistry",
    RegistryEndpointRef = "RegistryEndpointRef"
}

// @public
export enum KnownAkriConnectorsTagDigestType {
    Digest = "Digest",
    Tag = "Tag"
}

// @public
export enum KnownAkriConnectorTemplateAllocationPolicy {
    Bucketized = "Bucketized"
}

// @public
export enum KnownAkriConnectorTemplateHelmRegistrySettingsType {
    ContainerRegistry = "ContainerRegistry",
    RegistryEndpointRef = "RegistryEndpointRef"
}

// @public
export enum KnownAkriConnectorTemplateManagedConfigurationType {
    ImageConfiguration = "ImageConfiguration",
    StatefulSetConfiguration = "StatefulSetConfiguration"
}

// @public
export enum KnownAkriConnectorTemplateRuntimeConfigurationType {
    HelmConfiguration = "HelmConfiguration",
    ManagedConfiguration = "ManagedConfiguration"
}

// @public
export enum KnownAkriDiscoveryHandlerScheduleType {
    Continuous = "Continuous",
    Cron = "Cron",
    RunOnce = "RunOnce"
}

// @public
export enum KnownBrokerAuthenticationMethod {
    Custom = "Custom",
    ServiceAccountToken = "ServiceAccountToken",
    X509 = "X509"
}

// @public
export enum KnownBrokerAuthenticatorValidationMethods {
    AzureDeviceRegistry = "AzureDeviceRegistry",
    None = "None"
}

// @public
export enum KnownBrokerMemoryProfile {
    High = "High",
    Low = "Low",
    Medium = "Medium",
    Tiny = "Tiny"
}

// @public
export enum KnownBrokerPersistencePolicyMode {
    All = "All",
    Custom = "Custom",
    None = "None"
}

// @public
export enum KnownBrokerProtocolType {
    Mqtt = "Mqtt",
    WebSockets = "WebSockets"
}

// @public
export enum KnownBrokerResourceDefinitionMethods {
    Connect = "Connect",
    Publish = "Publish",
    Subscribe = "Subscribe"
}

// @public
export enum KnownBrokerStateStoreKeyType {
    Binary = "Binary",
    Pattern = "Pattern",
    String = "String"
}

// @public
export enum KnownCertManagerIssuerKind {
    ClusterIssuer = "ClusterIssuer",
    Issuer = "Issuer"
}

// @public
export enum KnownCloudEventAttributeType {
    CreateOrRemap = "CreateOrRemap",
    Propagate = "Propagate"
}

// @public
export enum KnownCreatedByType {
    Application = "Application",
    Key = "Key",
    ManagedIdentity = "ManagedIdentity",
    User = "User"
}

// @public
export enum KnownDataExplorerAuthMethod {
    SystemAssignedManagedIdentity = "SystemAssignedManagedIdentity",
    UserAssignedManagedIdentity = "UserAssignedManagedIdentity"
}

// @public
export enum KnownDataflowEndpointAuthenticationSaslType {
    Plain = "Plain",
    ScramSha256 = "ScramSha256",
    ScramSha512 = "ScramSha512"
}

// @public
export enum KnownDataflowEndpointFabricPathType {
    Files = "Files",
    Tables = "Tables"
}

// @public
export enum KnownDataflowEndpointKafkaAcks {
    All = "All",
    One = "One",
    Zero = "Zero"
}

// @public
export enum KnownDataflowEndpointKafkaCompression {
    Gzip = "Gzip",
    Lz4 = "Lz4",
    None = "None",
    Snappy = "Snappy"
}

// @public
export enum KnownDataflowEndpointKafkaPartitionStrategy {
    Default = "Default",
    Property = "Property",
    Static = "Static",
    Topic = "Topic"
}

// @public
export enum KnownDataflowEnpointHostType {
    CustomKafka = "CustomKafka",
    CustomMqtt = "CustomMqtt",
    EventGrid = "EventGrid",
    Eventhub = "Eventhub",
    FabricRT = "FabricRT",
    LocalBroker = "LocalBroker"
}

// @public
export enum KnownDataflowGraphNodeType {
    Destination = "Destination",
    Graph = "Graph",
    Source = "Source"
}

// @public
export enum KnownDataflowGraphSerializationFormat {
    Avro = "Avro",
    Delta = "Delta",
    Json = "Json",
    Parquet = "Parquet"
}

// @public
export enum KnownDataflowMappingType {
    BuiltInFunction = "BuiltInFunction",
    Compute = "Compute",
    NewProperties = "NewProperties",
    PassThrough = "PassThrough",
    Rename = "Rename"
}

// @public
export enum KnownDataflowOpenTelemetryAuthenticationMethod {
    Anonymous = "Anonymous",
    ServiceAccountToken = "ServiceAccountToken",
    X509Certificate = "X509Certificate"
}

// @public
export enum KnownDataLakeStorageAuthMethod {
    AccessToken = "AccessToken",
    SystemAssignedManagedIdentity = "SystemAssignedManagedIdentity",
    UserAssignedManagedIdentity = "UserAssignedManagedIdentity"
}

// @public
export enum KnownEndpointType {
    DataExplorer = "DataExplorer",
    DataLakeStorage = "DataLakeStorage",
    FabricOneLake = "FabricOneLake",
    Kafka = "Kafka",
    LocalStorage = "LocalStorage",
    Mqtt = "Mqtt",
    OpenTelemetry = "OpenTelemetry"
}

// @public
export enum KnownExtendedLocationType {
    CustomLocation = "CustomLocation"
}

// @public
export enum KnownFabricOneLakeAuthMethod {
    SystemAssignedManagedIdentity = "SystemAssignedManagedIdentity",
    UserAssignedManagedIdentity = "UserAssignedManagedIdentity"
}

// @public
export enum KnownFilterType {
    Filter = "Filter"
}

// @public
export enum KnownInstanceFeatureMode {
    Disabled = "Disabled",
    Preview = "Preview",
    Stable = "Stable"
}

// @public
export enum KnownKafkaAuthMethod {
    Anonymous = "Anonymous",
    Sasl = "Sasl",
    SystemAssignedManagedIdentity = "SystemAssignedManagedIdentity",
    UserAssignedManagedIdentity = "UserAssignedManagedIdentity",
    X509Certificate = "X509Certificate"
}

// @public
export enum KnownManagedServiceIdentityType {
    None = "None",
    SystemAssigned = "SystemAssigned",
    SystemAssignedUserAssigned = "SystemAssigned,UserAssigned",
    UserAssigned = "UserAssigned"
}

// @public
export enum KnownMqttAuthMethod {
    Anonymous = "Anonymous",
    ServiceAccountToken = "ServiceAccountToken",
    SystemAssignedManagedIdentity = "SystemAssignedManagedIdentity",
    UserAssignedManagedIdentity = "UserAssignedManagedIdentity",
    X509Certificate = "X509Certificate"
}

// @public
export enum KnownMqttRetainType {
    Keep = "Keep",
    Never = "Never"
}

// @public
export enum KnownOperationalMode {
    Disabled = "Disabled",
    Enabled = "Enabled"
}

// @public
export enum KnownOperationType {
    BuiltInTransformation = "BuiltInTransformation",
    Destination = "Destination",
    Source = "Source"
}

// @public
export enum KnownOperatorValues {
    DoesNotExist = "DoesNotExist",
    Exists = "Exists",
    In = "In",
    NotIn = "NotIn"
}

// @public
export enum KnownOrigin {
    System = "system",
    User = "user",
    UserSystem = "user,system"
}

// @public
export enum KnownPrivateKeyAlgorithm {
    Ec256 = "Ec256",
    Ec384 = "Ec384",
    Ec521 = "Ec521",
    Ed25519 = "Ed25519",
    Rsa2048 = "Rsa2048",
    Rsa4096 = "Rsa4096",
    Rsa8192 = "Rsa8192"
}

// @public
export enum KnownPrivateKeyRotationPolicy {
    Always = "Always",
    Never = "Never"
}

// @public
export enum KnownProvisioningState {
    Accepted = "Accepted",
    Canceled = "Canceled",
    Deleting = "Deleting",
    Failed = "Failed",
    Provisioning = "Provisioning",
    Succeeded = "Succeeded",
    Updating = "Updating"
}

// @public
export enum KnownRegistryEndpointAuthenticationMethod {
    Anonymous = "Anonymous",
    ArtifactPullSecret = "ArtifactPullSecret",
    SystemAssignedManagedIdentity = "SystemAssignedManagedIdentity",
    UserAssignedManagedIdentity = "UserAssignedManagedIdentity"
}

// @public
export enum KnownRegistryEndpointTrustedSigningKeyType {
    ConfigMap = "ConfigMap",
    Secret = "Secret"
}

// @public
export enum KnownServiceType {
    ClusterIp = "ClusterIp",
    LoadBalancer = "LoadBalancer",
    NodePort = "NodePort"
}

// @public
export enum KnownSourceSerializationFormat {
    Json = "Json"
}

// @public
export enum KnownStateStoreResourceDefinitionMethods {
    Read = "Read",
    ReadWrite = "ReadWrite",
    Write = "Write"
}

// @public
export enum KnownStateStoreResourceKeyTypes {
    Binary = "Binary",
    Pattern = "Pattern",
    String = "String"
}

// @public
export enum KnownSubscriberMessageDropStrategy {
    DropOldest = "DropOldest",
    None = "None"
}

// @public
export enum KnownTlsCertMethodMode {
    Automatic = "Automatic",
    Manual = "Manual"
}

// @public
export enum KnownTransformationSerializationFormat {
    Delta = "Delta",
    Json = "Json",
    Parquet = "Parquet"
}

// @public
export enum KnownVersions {
    "V2024-11-01" = "2024-11-01",
    _20250701Preview = "2025-07-01-preview",
    V20250401 = "2025-04-01"
}

// @public
export interface KubernetesReference {
    apiGroup?: string;
    kind: string;
    name: string;
    namespace?: string;
}

// @public
export interface ListenerPort {
    authenticationRef?: string;
    authorizationRef?: string;
    nodePort?: number;
    port: number;
    protocol?: BrokerProtocolType;
    tls?: TlsCertMethod;
}

// @public
export interface LocalKubernetesReference {
    apiGroup?: string;
    kind: string;
    name: string;
}

// @public
export interface ManagedServiceIdentity {
    readonly principalId?: string;
    readonly tenantId?: string;
    type: ManagedServiceIdentityType;
    userAssignedIdentities?: Record<string, UserAssignedIdentity | null>;
}

// @public
export type ManagedServiceIdentityType = string;

// @public
export interface Metrics {
    prometheusPort?: number;
}

// @public
export type MqttAuthMethod = string;

// @public
export type MqttRetainType = string;

// @public
export interface Operation {
    readonly actionType?: ActionType;
    display?: OperationDisplay;
    readonly isDataAction?: boolean;
    readonly name?: string;
    readonly origin?: Origin;
}

// @public
export type OperationalMode = string;

// @public
export interface OperationDisplay {
    readonly description?: string;
    readonly operation?: string;
    readonly provider?: string;
    readonly resource?: string;
}

// @public
export type OperationType = string;

// @public
export type OperatorValues = string;

// @public
export type Origin = string;

// @public
export interface PrincipalDefinition {
    attributes?: Record<string, string>[];
    clientIds?: string[];
    usernames?: string[];
}

// @public
export type PrivateKeyAlgorithm = string;

// @public
export type PrivateKeyRotationPolicy = string;

// @public
export interface ProfileDiagnostics {
    logs?: DiagnosticsLogs;
    metrics?: Metrics;
}

// @public
export type ProvisioningState = string;

// @public
export interface ProxyResource extends Resource {
}

// @public
export interface RegistryEndpointAnonymousAuthentication extends RegistryEndpointAuthentication {
    anonymousSettings: RegistryEndpointAnonymousSettings;
    method: "Anonymous";
}

// @public
export interface RegistryEndpointAnonymousSettings {
}

// @public
export interface RegistryEndpointArtifactPullSecretAuthentication extends RegistryEndpointAuthentication {
    artifactPullSecretSettings: RegistryEndpointArtifactPullSecretSettings;
    method: "ArtifactPullSecret";
}

// @public
export interface RegistryEndpointArtifactPullSecretSettings {
    secretRef: string;
}

// @public
export interface RegistryEndpointAuthentication {
    method: RegistryEndpointAuthenticationMethod;
}

// @public
export type RegistryEndpointAuthenticationMethod = string;

// @public
export type RegistryEndpointAuthenticationUnion = RegistryEndpointSystemAssignedIdentityAuthentication | RegistryEndpointUserAssignedIdentityAuthentication | RegistryEndpointAnonymousAuthentication | RegistryEndpointArtifactPullSecretAuthentication | RegistryEndpointAuthentication;

// @public
export interface RegistryEndpointProperties {
    authentication: RegistryEndpointAuthenticationUnion;
    host: string;
    readonly provisioningState?: ProvisioningState;
    trustSettings?: RegistryEndpointTrustedSettings;
}

// @public
export interface RegistryEndpointResource extends ProxyResource {
    extendedLocation?: ExtendedLocation;
    properties?: RegistryEndpointProperties;
}

// @public
export interface RegistryEndpointSystemAssignedIdentityAuthentication extends RegistryEndpointAuthentication {
    method: "SystemAssignedManagedIdentity";
    systemAssignedManagedIdentitySettings: RegistryEndpointSystemAssignedManagedIdentitySettings;
}

// @public
export interface RegistryEndpointSystemAssignedManagedIdentitySettings {
    audience?: string;
}

// @public
export interface RegistryEndpointTrustedSettings {
    trustedSigningKeys: RegistryEndpointTrustedSigningKeyUnion;
}

// @public
export interface RegistryEndpointTrustedSigningKey {
    type: RegistryEndpointTrustedSigningKeyType;
}

// @public
export interface RegistryEndpointTrustedSigningKeyConfigMap extends RegistryEndpointTrustedSigningKey {
    configMapRef: string;
    type: "ConfigMap";
}

// @public
export interface RegistryEndpointTrustedSigningKeySecret extends RegistryEndpointTrustedSigningKey {
    secretRef: string;
    type: "Secret";
}

// @public
export type RegistryEndpointTrustedSigningKeyType = string;

// @public
export type RegistryEndpointTrustedSigningKeyUnion = RegistryEndpointTrustedSigningKeySecret | RegistryEndpointTrustedSigningKeyConfigMap | RegistryEndpointTrustedSigningKey;

// @public
export interface RegistryEndpointUserAssignedIdentityAuthentication extends RegistryEndpointAuthentication {
    method: "UserAssignedManagedIdentity";
    userAssignedManagedIdentitySettings: RegistryEndpointUserAssignedManagedIdentitySettings;
}

// @public
export interface RegistryEndpointUserAssignedManagedIdentitySettings {
    clientId: string;
    scope?: string;
    tenantId: string;
}

// @public
export interface Resource {
    readonly id?: string;
    readonly name?: string;
    readonly systemData?: SystemData;
    readonly type?: string;
}

// @public
export interface SanForCert {
    dns: string[];
    ip: string[];
}

// @public
export interface SchemaRegistryRef {
    resourceId: string;
}

// @public
export interface SecretProviderClassRef {
    resourceId: string;
}

// @public
export interface SelfCheck {
    intervalSeconds?: number;
    mode?: OperationalMode;
    timeoutSeconds?: number;
}

// @public
export interface SelfTracing {
    intervalSeconds?: number;
    mode?: OperationalMode;
}

// @public
export type ServiceType = string;

// @public
export type SourceSerializationFormat = string;

// @public
export type StateStoreResourceDefinitionMethods = string;

// @public
export type StateStoreResourceKeyTypes = string;

// @public
export interface StateStoreResourceRule {
    keys: string[];
    keyType: StateStoreResourceKeyTypes;
    method: StateStoreResourceDefinitionMethods;
}

// @public
export type SubscriberMessageDropStrategy = string;

// @public
export interface SubscriberQueueLimit {
    length?: number;
    strategy?: SubscriberMessageDropStrategy;
}

// @public
export interface SystemData {
    createdAt?: Date;
    createdBy?: string;
    createdByType?: CreatedByType;
    lastModifiedAt?: Date;
    lastModifiedBy?: string;
    lastModifiedByType?: CreatedByType;
}

// @public
export interface TlsCertMethod {
    certManagerCertificateSpec?: CertManagerCertificateSpec;
    manual?: X509ManualCertificate;
    mode: TlsCertMethodMode;
}

// @public
export type TlsCertMethodMode = string;

// @public
export interface TlsProperties {
    mode?: OperationalMode;
    trustedCaCertificateConfigMapRef?: string;
}

// @public
export interface Traces {
    cacheSizeMegabytes?: number;
    mode?: OperationalMode;
    selfTracing?: SelfTracing;
    spanChannelCapacity?: number;
}

// @public
export interface TrackedResource extends Resource {
    location: string;
    tags?: Record<string, string>;
}

// @public
export type TransformationSerializationFormat = string;

// @public
export interface UserAssignedIdentity {
    readonly clientId?: string;
    readonly principalId?: string;
}

// @public
export interface VolumeClaimResourceRequirements {
    claims?: VolumeClaimResourceRequirementsClaims[];
    limits?: Record<string, string>;
    requests?: Record<string, string>;
}

// @public
export interface VolumeClaimResourceRequirementsClaims {
    name: string;
}

// @public
export interface VolumeClaimSpec {
    accessModes?: string[];
    dataSource?: LocalKubernetesReference;
    dataSourceRef?: KubernetesReference;
    resources?: VolumeClaimResourceRequirements;
    selector?: VolumeClaimSpecSelector;
    storageClassName?: string;
    volumeMode?: string;
    volumeName?: string;
}

// @public
export interface VolumeClaimSpecSelector {
    matchExpressions?: VolumeClaimSpecSelectorMatchExpressions[];
    matchLabels?: Record<string, string>;
}

// @public
export interface VolumeClaimSpecSelectorMatchExpressions {
    key: string;
    operator: OperatorValues;
    values?: string[];
}

// @public
export interface X509ManualCertificate {
    secretRef: string;
}

// (No @packageDocumentation comment for this package)

```
