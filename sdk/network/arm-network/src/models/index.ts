/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import * as coreClient from "@azure/core-client";

/** Common resource representation. */
export interface Resource {
  /** Resource ID. */
  id?: string;
  /**
   * Resource name.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly name?: string;
  /**
   * Resource type.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly type?: string;
  /** Resource location. */
  location?: string;
  /** Resource tags. */
  tags?: { [propertyName: string]: string };
}

/** The error object. */
export interface ErrorResponse {
  /** The error details object. */
  error?: ErrorDetails;
}

/** Common error details representation. */
export interface ErrorDetails {
  /** Error code. */
  code?: string;
  /** Error target. */
  target?: string;
  /** Error message. */
  message?: string;
}

/** Tags object for patch operations. */
export interface TagsObject {
  /** Resource tags. */
  tags?: { [propertyName: string]: string };
}

/** Response for ListNetworkWatchers API service call. */
export interface NetworkWatcherListResult {
  /** List of network watcher resources. */
  value?: NetworkWatcher[];
}

/** Parameters that define the representation of topology. */
export interface TopologyParameters {
  /** The name of the target resource group to perform topology on. */
  targetResourceGroupName?: string;
  /** The reference to the Virtual Network resource. */
  targetVirtualNetwork?: SubResource;
  /** The reference to the Subnet resource. */
  targetSubnet?: SubResource;
}

/** Reference to another subresource. */
export interface SubResource {
  /** Resource ID. */
  id?: string;
}

/** Topology of the specified resource group. */
export interface Topology {
  /**
   * GUID representing the operation id.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly id?: string;
  /**
   * The datetime when the topology was initially created for the resource group.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly createdDateTime?: Date;
  /**
   * The datetime when the topology was last modified.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly lastModified?: Date;
  /** A list of topology resources. */
  resources?: TopologyResource[];
}

/** The network resource topology information for the given resource group. */
export interface TopologyResource {
  /** Name of the resource. */
  name?: string;
  /** ID of the resource. */
  id?: string;
  /** Resource location. */
  location?: string;
  /** Holds the associations the resource has with other resources in the resource group. */
  associations?: TopologyAssociation[];
}

/** Resources that have an association with the parent resource. */
export interface TopologyAssociation {
  /** The name of the resource that is associated with the parent resource. */
  name?: string;
  /** The ID of the resource that is associated with the parent resource. */
  resourceId?: string;
  /** The association type of the child resource to the parent resource. */
  associationType?: AssociationType;
}

/** Parameters that define the IP flow to be verified. */
export interface VerificationIPFlowParameters {
  /** The ID of the target resource to perform next-hop on. */
  targetResourceId: string;
  /** The direction of the packet represented as a 5-tuple. */
  direction: Direction;
  /** Protocol to be verified on. */
  protocol: IpFlowProtocol;
  /** The local port. Acceptable values are a single integer in the range (0-65535). Support for * for the source port, which depends on the direction. */
  localPort: string;
  /** The remote port. Acceptable values are a single integer in the range (0-65535). Support for * for the source port, which depends on the direction. */
  remotePort: string;
  /** The local IP address. Acceptable values are valid IPv4 addresses. */
  localIPAddress: string;
  /** The remote IP address. Acceptable values are valid IPv4 addresses. */
  remoteIPAddress: string;
  /** The NIC ID. (If VM has multiple NICs and IP forwarding is enabled on any of them, then this parameter must be specified. Otherwise optional). */
  targetNicResourceId?: string;
}

/** Results of IP flow verification on the target resource. */
export interface VerificationIPFlowResult {
  /** Indicates whether the traffic is allowed or denied. */
  access?: Access;
  /** Name of the rule. If input is not matched against any security rule, it is not displayed. */
  ruleName?: string;
}

/** Parameters that define the source and destination endpoint. */
export interface NextHopParameters {
  /** The resource identifier of the target resource against which the action is to be performed. */
  targetResourceId: string;
  /** The source IP address. */
  sourceIPAddress: string;
  /** The destination IP address. */
  destinationIPAddress: string;
  /** The NIC ID. (If VM has multiple NICs and IP forwarding is enabled on any of the nics, then this parameter must be specified. Otherwise optional). */
  targetNicResourceId?: string;
}

/** The information about next hop from the specified VM. */
export interface NextHopResult {
  /** Next hop type. */
  nextHopType?: NextHopType;
  /** Next hop IP Address. */
  nextHopIpAddress?: string;
  /** The resource identifier for the route table associated with the route being returned. If the route being returned does not correspond to any user created routes then this field will be the string 'System Route'. */
  routeTableId?: string;
}

/** Parameters that define the VM to check security groups for. */
export interface SecurityGroupViewParameters {
  /** ID of the target VM. */
  targetResourceId: string;
}

/** The information about security rules applied to the specified VM. */
export interface SecurityGroupViewResult {
  /** List of network interfaces on the specified VM. */
  networkInterfaces?: SecurityGroupNetworkInterface[];
}

/** Network interface and all its associated security rules. */
export interface SecurityGroupNetworkInterface {
  /** ID of the network interface. */
  id?: string;
  /** All security rules associated with the network interface. */
  securityRuleAssociations?: SecurityRuleAssociations;
}

/** All security rules associated with the network interface. */
export interface SecurityRuleAssociations {
  /** Network interface and it's custom security rules. */
  networkInterfaceAssociation?: NetworkInterfaceAssociation;
  /** Subnet and it's custom security rules. */
  subnetAssociation?: SubnetAssociation;
  /** Collection of default security rules of the network security group. */
  defaultSecurityRules?: SecurityRule[];
  /** Collection of effective security rules. */
  effectiveSecurityRules?: EffectiveNetworkSecurityRule[];
}

/** Network interface and its custom security rules. */
export interface NetworkInterfaceAssociation {
  /**
   * Network interface ID.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly id?: string;
  /** Collection of custom security rules. */
  securityRules?: SecurityRule[];
}

/** Subnet and it's custom security rules. */
export interface SubnetAssociation {
  /**
   * Subnet ID.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly id?: string;
  /** Collection of custom security rules. */
  securityRules?: SecurityRule[];
}

/** Effective network security rules. */
export interface EffectiveNetworkSecurityRule {
  /** The name of the security rule specified by the user (if created by the user). */
  name?: string;
  /** The network protocol this rule applies to. */
  protocol?: EffectiveSecurityRuleProtocol;
  /** The source port or range. */
  sourcePortRange?: string;
  /** The destination port or range. */
  destinationPortRange?: string;
  /** The source port ranges. Expected values include a single integer between 0 and 65535, a range using '-' as separator (e.g. 100-400), or an asterisk (*). */
  sourcePortRanges?: string[];
  /** The destination port ranges. Expected values include a single integer between 0 and 65535, a range using '-' as separator (e.g. 100-400), or an asterisk (*). */
  destinationPortRanges?: string[];
  /** The source address prefix. */
  sourceAddressPrefix?: string;
  /** The destination address prefix. */
  destinationAddressPrefix?: string;
  /** The source address prefixes. Expected values include CIDR IP ranges, Default Tags (VirtualNetwork, AzureLoadBalancer, Internet), System Tags, and the asterisk (*). */
  sourceAddressPrefixes?: string[];
  /** The destination address prefixes. Expected values include CIDR IP ranges, Default Tags (VirtualNetwork, AzureLoadBalancer, Internet), System Tags, and the asterisk (*). */
  destinationAddressPrefixes?: string[];
  /** The expanded source address prefix. */
  expandedSourceAddressPrefix?: string[];
  /** Expanded destination address prefix. */
  expandedDestinationAddressPrefix?: string[];
  /** Whether network traffic is allowed or denied. */
  access?: SecurityRuleAccess;
  /** The priority of the rule. */
  priority?: number;
  /** The direction of the rule. */
  direction?: SecurityRuleDirection;
}

/** Parameters that define the create packet capture operation. */
export interface PacketCapture {
  /** The ID of the targeted resource, only AzureVM and AzureVMSS as target type are currently supported. */
  target: string;
  /** A list of AzureVMSS instances which can be included or excluded to run packet capture. If both included and excluded are empty, then the packet capture will run on all instances of AzureVMSS. */
  scope?: PacketCaptureMachineScope;
  /** Target type of the resource provided. */
  targetType?: PacketCaptureTargetType;
  /** Number of bytes captured per packet, the remaining bytes are truncated. */
  bytesToCapturePerPacket?: number;
  /** Maximum size of the capture output. */
  totalBytesPerSession?: number;
  /** Maximum duration of the capture session in seconds. */
  timeLimitInSeconds?: number;
  /** The storage location for a packet capture session. */
  storageLocation: PacketCaptureStorageLocation;
  /** A list of packet capture filters. */
  filters?: PacketCaptureFilter[];
}

/** Parameters that define the create packet capture operation. */
export interface PacketCaptureParameters {
  /** The ID of the targeted resource, only AzureVM and AzureVMSS as target type are currently supported. */
  target: string;
  /** A list of AzureVMSS instances which can be included or excluded to run packet capture. If both included and excluded are empty, then the packet capture will run on all instances of AzureVMSS. */
  scope?: PacketCaptureMachineScope;
  /** Target type of the resource provided. */
  targetType?: PacketCaptureTargetType;
  /** Number of bytes captured per packet, the remaining bytes are truncated. */
  bytesToCapturePerPacket?: number;
  /** Maximum size of the capture output. */
  totalBytesPerSession?: number;
  /** Maximum duration of the capture session in seconds. */
  timeLimitInSeconds?: number;
  /** The storage location for a packet capture session. */
  storageLocation: PacketCaptureStorageLocation;
  /** A list of packet capture filters. */
  filters?: PacketCaptureFilter[];
}

/** A list of AzureVMSS instances which can be included or excluded to run packet capture. If both included and excluded are empty, then the packet capture will run on all instances of AzureVMSS. */
export interface PacketCaptureMachineScope {
  /** List of AzureVMSS instances to run packet capture on. */
  include?: string[];
  /** List of AzureVMSS instances which has to be excluded from the AzureVMSS from running packet capture. */
  exclude?: string[];
}

/** The storage location for a packet capture session. */
export interface PacketCaptureStorageLocation {
  /** The ID of the storage account to save the packet capture session. Required if no local file path is provided. */
  storageId?: string;
  /** The URI of the storage path to save the packet capture. Must be a well-formed URI describing the location to save the packet capture. */
  storagePath?: string;
  /** A valid local path on the targeting VM. Must include the name of the capture file (*.cap). For linux virtual machine it must start with /var/captures. Required if no storage ID is provided, otherwise optional. */
  filePath?: string;
}

/** Filter that is applied to packet capture request. Multiple filters can be applied. */
export interface PacketCaptureFilter {
  /** Protocol to be filtered on. */
  protocol?: PcProtocol;
  /** Local IP Address to be filtered on. Notation: "127.0.0.1" for single address entry. "127.0.0.1-127.0.0.255" for range. "127.0.0.1;127.0.0.5"? for multiple entries. Multiple ranges not currently supported. Mixing ranges with multiple entries not currently supported. Default = null. */
  localIPAddress?: string;
  /** Local IP Address to be filtered on. Notation: "127.0.0.1" for single address entry. "127.0.0.1-127.0.0.255" for range. "127.0.0.1;127.0.0.5;" for multiple entries. Multiple ranges not currently supported. Mixing ranges with multiple entries not currently supported. Default = null. */
  remoteIPAddress?: string;
  /** Local port to be filtered on. Notation: "80" for single port entry."80-85" for range. "80;443;" for multiple entries. Multiple ranges not currently supported. Mixing ranges with multiple entries not currently supported. Default = null. */
  localPort?: string;
  /** Remote port to be filtered on. Notation: "80" for single port entry."80-85" for range. "80;443;" for multiple entries. Multiple ranges not currently supported. Mixing ranges with multiple entries not currently supported. Default = null. */
  remotePort?: string;
}

/** Information about packet capture session. */
export interface PacketCaptureResult {
  /**
   * Name of the packet capture session.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly name?: string;
  /**
   * ID of the packet capture operation.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly id?: string;
  /**
   * A unique read-only string that changes whenever the resource is updated.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly etag?: string;
  /** The ID of the targeted resource, only AzureVM and AzureVMSS as target type are currently supported. */
  target?: string;
  /** A list of AzureVMSS instances which can be included or excluded to run packet capture. If both included and excluded are empty, then the packet capture will run on all instances of AzureVMSS. */
  scope?: PacketCaptureMachineScope;
  /** Target type of the resource provided. */
  targetType?: PacketCaptureTargetType;
  /** Number of bytes captured per packet, the remaining bytes are truncated. */
  bytesToCapturePerPacket?: number;
  /** Maximum size of the capture output. */
  totalBytesPerSession?: number;
  /** Maximum duration of the capture session in seconds. */
  timeLimitInSeconds?: number;
  /** The storage location for a packet capture session. */
  storageLocation?: PacketCaptureStorageLocation;
  /** A list of packet capture filters. */
  filters?: PacketCaptureFilter[];
  /**
   * The provisioning state of the packet capture session.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly provisioningState?: ProvisioningState;
}

/** Status of packet capture session. */
export interface PacketCaptureQueryStatusResult {
  /** The name of the packet capture resource. */
  name?: string;
  /** The ID of the packet capture resource. */
  id?: string;
  /** The start time of the packet capture session. */
  captureStartTime?: Date;
  /** The status of the packet capture session. */
  packetCaptureStatus?: PcStatus;
  /** The reason the current packet capture session was stopped. */
  stopReason?: string;
  /** List of errors of packet capture session. */
  packetCaptureError?: PcError[];
}

/** List of packet capture sessions. */
export interface PacketCaptureListResult {
  /** Information about packet capture sessions. */
  value?: PacketCaptureResult[];
}

/** Parameters that define the resource to troubleshoot. */
export interface TroubleshootingParameters {
  /** The target resource to troubleshoot. */
  targetResourceId: string;
  /** The ID for the storage account to save the troubleshoot result. */
  storageId: string;
  /** The path to the blob to save the troubleshoot result in. */
  storagePath: string;
}

/** Troubleshooting information gained from specified resource. */
export interface TroubleshootingResult {
  /** The start time of the troubleshooting. */
  startTime?: Date;
  /** The end time of the troubleshooting. */
  endTime?: Date;
  /** The result code of the troubleshooting. */
  code?: string;
  /** Information from troubleshooting. */
  results?: TroubleshootingDetails[];
}

/** Information gained from troubleshooting of specified resource. */
export interface TroubleshootingDetails {
  /** The id of the get troubleshoot operation. */
  id?: string;
  /** Reason type of failure. */
  reasonType?: string;
  /** A summary of troubleshooting. */
  summary?: string;
  /** Details on troubleshooting results. */
  detail?: string;
  /** List of recommended actions. */
  recommendedActions?: TroubleshootingRecommendedActions[];
}

/** Recommended actions based on discovered issues. */
export interface TroubleshootingRecommendedActions {
  /** ID of the recommended action. */
  actionId?: string;
  /** Description of recommended actions. */
  actionText?: string;
  /** The uri linking to a documentation for the recommended troubleshooting actions. */
  actionUri?: string;
  /** The information from the URI for the recommended troubleshooting actions. */
  actionUriText?: string;
}

/** Parameters that define the resource to query the troubleshooting result. */
export interface QueryTroubleshootingParameters {
  /** The target resource ID to query the troubleshooting result. */
  targetResourceId: string;
}

/** Information on the configuration of flow log and traffic analytics (optional) . */
export interface FlowLogInformation {
  /** The ID of the resource to configure for flow log and traffic analytics (optional) . */
  targetResourceId: string;
  /** Parameters that define the configuration of traffic analytics. */
  flowAnalyticsConfiguration?: TrafficAnalyticsProperties;
  /** ID of the storage account which is used to store the flow log. */
  storageId: string;
  /** Flag to enable/disable flow logging. */
  enabled: boolean;
  /** Parameters that define the retention policy for flow log. */
  retentionPolicy?: RetentionPolicyParameters;
  /** Parameters that define the flow log format. */
  format?: FlowLogFormatParameters;
}

/** Parameters that define the retention policy for flow log. */
export interface RetentionPolicyParameters {
  /** Number of days to retain flow log records. */
  days?: number;
  /** Flag to enable/disable retention. */
  enabled?: boolean;
}

/** Parameters that define the flow log format. */
export interface FlowLogFormatParameters {
  /** The file type of flow log. */
  type?: FlowLogFormatType;
  /** The version (revision) of the flow log. */
  version?: number;
}

/** Parameters that define the configuration of traffic analytics. */
export interface TrafficAnalyticsProperties {
  /** Parameters that define the configuration of traffic analytics. */
  networkWatcherFlowAnalyticsConfiguration?: TrafficAnalyticsConfigurationProperties;
}

/** Parameters that define the configuration of traffic analytics. */
export interface TrafficAnalyticsConfigurationProperties {
  /** Flag to enable/disable traffic analytics. */
  enabled?: boolean;
  /** The resource guid of the attached workspace. */
  workspaceId?: string;
  /** The location of the attached workspace. */
  workspaceRegion?: string;
  /** Resource Id of the attached workspace. */
  workspaceResourceId?: string;
  /** The interval in minutes which would decide how frequently TA service should do flow analytics. */
  trafficAnalyticsInterval?: number;
}

/** Parameters that define a resource to query flow log and traffic analytics (optional) status. */
export interface FlowLogStatusParameters {
  /** The target resource where getting the flow log and traffic analytics (optional) status. */
  targetResourceId: string;
}

/** Parameters that determine how the connectivity check will be performed. */
export interface ConnectivityParameters {
  /** The source of the connection. */
  source: ConnectivitySource;
  /** The destination of connection. */
  destination: ConnectivityDestination;
  /** Network protocol. */
  protocol?: Protocol;
  /** Configuration of the protocol. */
  protocolConfiguration?: ProtocolConfiguration;
  /** Preferred IP version of the connection. */
  preferredIPVersion?: IPVersion;
}

/** Parameters that define the source of the connection. */
export interface ConnectivitySource {
  /** The ID of the resource from which a connectivity check will be initiated. */
  resourceId: string;
  /** The source port from which a connectivity check will be performed. */
  port?: number;
}

/** Parameters that define destination of connection. */
export interface ConnectivityDestination {
  /** The ID of the resource to which a connection attempt will be made. */
  resourceId?: string;
  /** The IP address or URI the resource to which a connection attempt will be made. */
  address?: string;
  /** Port on which check connectivity will be performed. */
  port?: number;
}

/** Configuration of the protocol. */
export interface ProtocolConfiguration {
  /** HTTP configuration of the connectivity check. */
  httpConfiguration?: HttpConfiguration;
}

/** HTTP configuration of the connectivity check. */
export interface HttpConfiguration {
  /** HTTP method. */
  method?: HttpMethod;
  /** List of HTTP headers. */
  headers?: HttpHeader[];
  /** Valid status codes. */
  validStatusCodes?: number[];
}

/** The HTTP header. */
export interface HttpHeader {
  /** The name in HTTP header. */
  name?: string;
  /** The value in HTTP header. */
  value?: string;
}

/** Information on the connectivity status. */
export interface ConnectivityInformation {
  /**
   * List of hops between the source and the destination.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly hops?: ConnectivityHop[];
  /**
   * The connection status.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly connectionStatus?: ConnectionStatus;
  /**
   * Average latency in milliseconds.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly avgLatencyInMs?: number;
  /**
   * Minimum latency in milliseconds.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly minLatencyInMs?: number;
  /**
   * Maximum latency in milliseconds.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly maxLatencyInMs?: number;
  /**
   * Total number of probes sent.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly probesSent?: number;
  /**
   * Number of failed probes.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly probesFailed?: number;
}

/** Information about a hop between the source and the destination. */
export interface ConnectivityHop {
  /**
   * The type of the hop.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly type?: string;
  /**
   * The ID of the hop.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly id?: string;
  /**
   * The IP address of the hop.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly address?: string;
  /**
   * The ID of the resource corresponding to this hop.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly resourceId?: string;
  /**
   * List of next hop identifiers.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly nextHopIds?: string[];
  /**
   * List of previous hop identifiers.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly previousHopIds?: string[];
  /**
   * List of hop links.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly links?: HopLink[];
  /**
   * List of previous hop links.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly previousLinks?: HopLink[];
  /**
   * List of issues.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly issues?: ConnectivityIssue[];
}

/** Hop link. */
export interface HopLink {
  /**
   * The ID of the next hop.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly nextHopId?: string;
  /**
   * Link type.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly linkType?: string;
  /**
   * List of issues.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly issues?: ConnectivityIssue[];
  /**
   * Provides additional context on links.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly context?: { [propertyName: string]: string };
  /**
   * Resource ID.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly resourceId?: string;
  /**
   * Minimum roundtrip time in milliseconds.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly roundTripTimeMin?: number;
  /**
   * Average roundtrip time in milliseconds.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly roundTripTimeAvg?: number;
  /**
   * Maximum roundtrip time in milliseconds.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly roundTripTimeMax?: number;
}

/** Information about an issue encountered in the process of checking for connectivity. */
export interface ConnectivityIssue {
  /**
   * The origin of the issue.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly origin?: Origin;
  /**
   * The severity of the issue.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly severity?: Severity;
  /**
   * The type of issue.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly type?: IssueType;
  /**
   * Provides additional context on the issue.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly context?: { [propertyName: string]: string }[];
}

/** Geographic and time constraints for Azure reachability report. */
export interface AzureReachabilityReportParameters {
  /** Parameters that define a geographic location. */
  providerLocation: AzureReachabilityReportLocation;
  /** List of Internet service providers. */
  providers?: string[];
  /** Optional Azure regions to scope the query to. */
  azureLocations?: string[];
  /** The start time for the Azure reachability report. */
  startTime: Date;
  /** The end time for the Azure reachability report. */
  endTime: Date;
}

/** Parameters that define a geographic location. */
export interface AzureReachabilityReportLocation {
  /** The name of the country. */
  country: string;
  /** The name of the state. */
  state?: string;
  /** The name of the city or town. */
  city?: string;
}

/** Azure reachability report details. */
export interface AzureReachabilityReport {
  /** The aggregation level of Azure reachability report. Can be Country, State or City. */
  aggregationLevel: string;
  /** Parameters that define a geographic location. */
  providerLocation: AzureReachabilityReportLocation;
  /** List of Azure reachability report items. */
  reachabilityReport: AzureReachabilityReportItem[];
}

/** Azure reachability report details for a given provider location. */
export interface AzureReachabilityReportItem {
  /** The Internet service provider. */
  provider?: string;
  /** The Azure region. */
  azureLocation?: string;
  /** List of latency details for each of the time series. */
  latencies?: AzureReachabilityReportLatencyInfo[];
}

/** Details on latency for a time series. */
export interface AzureReachabilityReportLatencyInfo {
  /** The time stamp. */
  timeStamp?: Date;
  /** The relative latency score between 1 and 100, higher values indicating a faster connection. */
  score?: number;
}

/** Constraints that determine the list of available Internet service providers. */
export interface AvailableProvidersListParameters {
  /** A list of Azure regions. */
  azureLocations?: string[];
  /** The country for available providers list. */
  country?: string;
  /** The state for available providers list. */
  state?: string;
  /** The city or town for available providers list. */
  city?: string;
}

/** List of available countries with details. */
export interface AvailableProvidersList {
  /** List of available countries. */
  countries: AvailableProvidersListCountry[];
}

/** Country details. */
export interface AvailableProvidersListCountry {
  /** The country name. */
  countryName?: string;
  /** A list of Internet service providers. */
  providers?: string[];
  /** List of available states in the country. */
  states?: AvailableProvidersListState[];
}

/** State details. */
export interface AvailableProvidersListState {
  /** The state name. */
  stateName?: string;
  /** A list of Internet service providers. */
  providers?: string[];
  /** List of available cities or towns in the state. */
  cities?: AvailableProvidersListCity[];
}

/** City or town details. */
export interface AvailableProvidersListCity {
  /** The city or town name. */
  cityName?: string;
  /** A list of Internet service providers. */
  providers?: string[];
}

/** Parameters to get network configuration diagnostic. */
export interface NetworkConfigurationDiagnosticParameters {
  /** The ID of the target resource to perform network configuration diagnostic. Valid options are VM, NetworkInterface, VMSS/NetworkInterface and Application Gateway. */
  targetResourceId: string;
  /** Verbosity level. */
  verbosityLevel?: VerbosityLevel;
  /** List of network configuration diagnostic profiles. */
  profiles: NetworkConfigurationDiagnosticProfile[];
}

/** Parameters to compare with network configuration. */
export interface NetworkConfigurationDiagnosticProfile {
  /** The direction of the traffic. */
  direction: Direction;
  /** Protocol to be verified on. Accepted values are '*', TCP, UDP. */
  protocol: string;
  /** Traffic source. Accepted values are '*', IP Address/CIDR, Service Tag. */
  source: string;
  /** Traffic destination. Accepted values are: '*', IP Address/CIDR, Service Tag. */
  destination: string;
  /** Traffic destination port. Accepted values are '*' and a single port in the range (0 - 65535). */
  destinationPort: string;
}

/** Results of network configuration diagnostic on the target resource. */
export interface NetworkConfigurationDiagnosticResponse {
  /**
   * List of network configuration diagnostic results.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly results?: NetworkConfigurationDiagnosticResult[];
}

/** Network configuration diagnostic result corresponded to provided traffic query. */
export interface NetworkConfigurationDiagnosticResult {
  /** Network configuration diagnostic profile. */
  profile?: NetworkConfigurationDiagnosticProfile;
  /** Network security group result. */
  networkSecurityGroupResult?: NetworkSecurityGroupResult;
}

/** Network configuration diagnostic result corresponded provided traffic query. */
export interface NetworkSecurityGroupResult {
  /** The network traffic is allowed or denied. */
  securityRuleAccessResult?: SecurityRuleAccess;
  /**
   * List of results network security groups diagnostic.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly evaluatedNetworkSecurityGroups?: EvaluatedNetworkSecurityGroup[];
}

/** Results of network security group evaluation. */
export interface EvaluatedNetworkSecurityGroup {
  /** Network security group ID. */
  networkSecurityGroupId?: string;
  /** Resource ID of nic or subnet to which network security group is applied. */
  appliedTo?: string;
  /** Matched network security rule. */
  matchedRule?: MatchedRule;
  /**
   * List of network security rules evaluation results.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly rulesEvaluationResult?: NetworkSecurityRulesEvaluationResult[];
}

/** Matched rule. */
export interface MatchedRule {
  /** Name of the matched network security rule. */
  ruleName?: string;
  /** The network traffic is allowed or denied. Possible values are 'Allow' and 'Deny'. */
  action?: string;
}

/** Network security rules evaluation result. */
export interface NetworkSecurityRulesEvaluationResult {
  /** Name of the network security rule. */
  name?: string;
  /** Value indicating whether protocol is matched. */
  protocolMatched?: boolean;
  /** Value indicating whether source is matched. */
  sourceMatched?: boolean;
  /** Value indicating whether source port is matched. */
  sourcePortMatched?: boolean;
  /** Value indicating whether destination is matched. */
  destinationMatched?: boolean;
  /** Value indicating whether destination port is matched. */
  destinationPortMatched?: boolean;
}

/** Parameters that define the operation to create a connection monitor. */
export interface ConnectionMonitor {
  /** Connection monitor location. */
  location?: string;
  /** Connection monitor tags. */
  tags?: { [propertyName: string]: string };
  /** Describes the source of connection monitor. */
  source?: ConnectionMonitorSource;
  /** Describes the destination of connection monitor. */
  destination?: ConnectionMonitorDestination;
  /** Determines if the connection monitor will start automatically once created. */
  autoStart?: boolean;
  /** Monitoring interval in seconds. */
  monitoringIntervalInSeconds?: number;
  /** List of connection monitor endpoints. */
  endpoints?: ConnectionMonitorEndpoint[];
  /** List of connection monitor test configurations. */
  testConfigurations?: ConnectionMonitorTestConfiguration[];
  /** List of connection monitor test groups. */
  testGroups?: ConnectionMonitorTestGroup[];
  /** List of connection monitor outputs. */
  outputs?: ConnectionMonitorOutput[];
  /** Optional notes to be associated with the connection monitor. */
  notes?: string;
}

/** Parameters that define the operation to create a connection monitor. */
export interface ConnectionMonitorParameters {
  /** Describes the source of connection monitor. */
  source?: ConnectionMonitorSource;
  /** Describes the destination of connection monitor. */
  destination?: ConnectionMonitorDestination;
  /** Determines if the connection monitor will start automatically once created. */
  autoStart?: boolean;
  /** Monitoring interval in seconds. */
  monitoringIntervalInSeconds?: number;
  /** List of connection monitor endpoints. */
  endpoints?: ConnectionMonitorEndpoint[];
  /** List of connection monitor test configurations. */
  testConfigurations?: ConnectionMonitorTestConfiguration[];
  /** List of connection monitor test groups. */
  testGroups?: ConnectionMonitorTestGroup[];
  /** List of connection monitor outputs. */
  outputs?: ConnectionMonitorOutput[];
  /** Optional notes to be associated with the connection monitor. */
  notes?: string;
}

/** Describes the source of connection monitor. */
export interface ConnectionMonitorSource {
  /** The ID of the resource used as the source by connection monitor. */
  resourceId: string;
  /** The source port used by connection monitor. */
  port?: number;
}

/** Describes the destination of connection monitor. */
export interface ConnectionMonitorDestination {
  /** The ID of the resource used as the destination by connection monitor. */
  resourceId?: string;
  /** Address of the connection monitor destination (IP or domain name). */
  address?: string;
  /** The destination port used by connection monitor. */
  port?: number;
}

/** Describes the connection monitor endpoint. */
export interface ConnectionMonitorEndpoint {
  /** The name of the connection monitor endpoint. */
  name: string;
  /** The endpoint type. */
  type?: EndpointType;
  /** Resource ID of the connection monitor endpoint. */
  resourceId?: string;
  /** Address of the connection monitor endpoint (IP or domain name). */
  address?: string;
  /** Filter for sub-items within the endpoint. */
  filter?: ConnectionMonitorEndpointFilter;
  /** Endpoint scope. */
  scope?: ConnectionMonitorEndpointScope;
  /** Test coverage for the endpoint. */
  coverageLevel?: CoverageLevel;
  /** Location details for connection monitor endpoint. */
  locationDetails?: ConnectionMonitorEndpointLocationDetails;
  /** Subscription ID for connection monitor endpoint. */
  subscriptionId?: string;
}

/** Describes the connection monitor endpoint filter. */
export interface ConnectionMonitorEndpointFilter {
  /** The behavior of the endpoint filter. Currently only 'Include' is supported. */
  type?: ConnectionMonitorEndpointFilterType;
  /** List of items in the filter. */
  items?: ConnectionMonitorEndpointFilterItem[];
}

/** Describes the connection monitor endpoint filter item. */
export interface ConnectionMonitorEndpointFilterItem {
  /** The type of item included in the filter. Currently only 'AgentAddress' is supported. */
  type?: ConnectionMonitorEndpointFilterItemType;
  /** The address of the filter item. */
  address?: string;
}

/** Describes the connection monitor endpoint scope. */
export interface ConnectionMonitorEndpointScope {
  /** List of items which needs to be included to the endpoint scope. */
  include?: ConnectionMonitorEndpointScopeItem[];
  /** List of items which needs to be excluded from the endpoint scope. */
  exclude?: ConnectionMonitorEndpointScopeItem[];
}

/** Describes the connection monitor endpoint scope item. */
export interface ConnectionMonitorEndpointScopeItem {
  /** The address of the endpoint item. Supported types are IPv4/IPv6 subnet mask or IPv4/IPv6 IP address. */
  address?: string;
}

/** Connection monitor endpoint location details. */
export interface ConnectionMonitorEndpointLocationDetails {
  /** Region for connection monitor endpoint. */
  region?: string;
}

/** Describes a connection monitor test configuration. */
export interface ConnectionMonitorTestConfiguration {
  /** The name of the connection monitor test configuration. */
  name: string;
  /** The frequency of test evaluation, in seconds. */
  testFrequencySec?: number;
  /** The protocol to use in test evaluation. */
  protocol: ConnectionMonitorTestConfigurationProtocol;
  /** The preferred IP version to use in test evaluation. The connection monitor may choose to use a different version depending on other parameters. */
  preferredIPVersion?: PreferredIPVersion;
  /** The parameters used to perform test evaluation over HTTP. */
  httpConfiguration?: ConnectionMonitorHttpConfiguration;
  /** The parameters used to perform test evaluation over TCP. */
  tcpConfiguration?: ConnectionMonitorTcpConfiguration;
  /** The parameters used to perform test evaluation over ICMP. */
  icmpConfiguration?: ConnectionMonitorIcmpConfiguration;
  /** The threshold for declaring a test successful. */
  successThreshold?: ConnectionMonitorSuccessThreshold;
}

/** Describes the HTTP configuration. */
export interface ConnectionMonitorHttpConfiguration {
  /** The port to connect to. */
  port?: number;
  /** The HTTP method to use. */
  method?: HttpConfigurationMethod;
  /** The path component of the URI. For instance, "/dir1/dir2". */
  path?: string;
  /** The HTTP headers to transmit with the request. */
  requestHeaders?: HttpHeader[];
  /** HTTP status codes to consider successful. For instance, "2xx,301-304,418". */
  validStatusCodeRanges?: string[];
  /** Value indicating whether HTTPS is preferred over HTTP in cases where the choice is not explicit. */
  preferHttps?: boolean;
}

/** Describes the TCP configuration. */
export interface ConnectionMonitorTcpConfiguration {
  /** The port to connect to. */
  port?: number;
  /** Value indicating whether path evaluation with trace route should be disabled. */
  disableTraceRoute?: boolean;
  /** Destination port behavior. */
  destinationPortBehavior?: DestinationPortBehavior;
}

/** Describes the ICMP configuration. */
export interface ConnectionMonitorIcmpConfiguration {
  /** Value indicating whether path evaluation with trace route should be disabled. */
  disableTraceRoute?: boolean;
}

/** Describes the threshold for declaring a test successful. */
export interface ConnectionMonitorSuccessThreshold {
  /** The maximum percentage of failed checks permitted for a test to evaluate as successful. */
  checksFailedPercent?: number;
  /** The maximum round-trip time in milliseconds permitted for a test to evaluate as successful. */
  roundTripTimeMs?: number;
}

/** Describes the connection monitor test group. */
export interface ConnectionMonitorTestGroup {
  /** The name of the connection monitor test group. */
  name: string;
  /** Value indicating whether test group is disabled. */
  disable?: boolean;
  /** List of test configuration names. */
  testConfigurations: string[];
  /** List of source endpoint names. */
  sources: string[];
  /** List of destination endpoint names. */
  destinations: string[];
}

/** Describes a connection monitor output destination. */
export interface ConnectionMonitorOutput {
  /** Connection monitor output destination type. Currently, only "Workspace" is supported. */
  type?: OutputType;
  /** Describes the settings for producing output into a log analytics workspace. */
  workspaceSettings?: ConnectionMonitorWorkspaceSettings;
}

/** Describes the settings for producing output into a log analytics workspace. */
export interface ConnectionMonitorWorkspaceSettings {
  /** Log analytics workspace resource ID. */
  workspaceResourceId?: string;
}

/** Information about the connection monitor. */
export interface ConnectionMonitorResult {
  /**
   * Name of the connection monitor.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly name?: string;
  /**
   * ID of the connection monitor.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly id?: string;
  /**
   * A unique read-only string that changes whenever the resource is updated.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly etag?: string;
  /**
   * Connection monitor type.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly type?: string;
  /** Connection monitor location. */
  location?: string;
  /** Connection monitor tags. */
  tags?: { [propertyName: string]: string };
  /** Describes the source of connection monitor. */
  source?: ConnectionMonitorSource;
  /** Describes the destination of connection monitor. */
  destination?: ConnectionMonitorDestination;
  /** Determines if the connection monitor will start automatically once created. */
  autoStart?: boolean;
  /** Monitoring interval in seconds. */
  monitoringIntervalInSeconds?: number;
  /** List of connection monitor endpoints. */
  endpoints?: ConnectionMonitorEndpoint[];
  /** List of connection monitor test configurations. */
  testConfigurations?: ConnectionMonitorTestConfiguration[];
  /** List of connection monitor test groups. */
  testGroups?: ConnectionMonitorTestGroup[];
  /** List of connection monitor outputs. */
  outputs?: ConnectionMonitorOutput[];
  /** Optional notes to be associated with the connection monitor. */
  notes?: string;
  /**
   * The provisioning state of the connection monitor.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly provisioningState?: ProvisioningState;
  /**
   * The date and time when the connection monitor was started.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly startTime?: Date;
  /**
   * The monitoring status of the connection monitor.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly monitoringStatus?: string;
  /**
   * Type of connection monitor.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly connectionMonitorType?: ConnectionMonitorType;
}

/** List of connection states snapshots. */
export interface ConnectionMonitorQueryResult {
  /** Status of connection monitor source. */
  sourceStatus?: ConnectionMonitorSourceStatus;
  /** Information about connection states. */
  states?: ConnectionStateSnapshot[];
}

/** Connection state snapshot. */
export interface ConnectionStateSnapshot {
  /** The connection state. */
  connectionState?: ConnectionState;
  /** The start time of the connection snapshot. */
  startTime?: Date;
  /** The end time of the connection snapshot. */
  endTime?: Date;
  /** Connectivity analysis evaluation state. */
  evaluationState?: EvaluationState;
  /** Average latency in ms. */
  avgLatencyInMs?: number;
  /** Minimum latency in ms. */
  minLatencyInMs?: number;
  /** Maximum latency in ms. */
  maxLatencyInMs?: number;
  /** The number of sent probes. */
  probesSent?: number;
  /** The number of failed probes. */
  probesFailed?: number;
  /**
   * List of hops between the source and the destination.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly hops?: ConnectivityHop[];
}

/** List of connection monitors. */
export interface ConnectionMonitorListResult {
  /** Information about connection monitors. */
  value?: ConnectionMonitorResult[];
}

/** List of flow logs. */
export interface FlowLogListResult {
  /** Information about flow log resource. */
  value?: FlowLog[];
  /**
   * The URL to get the next set of results.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly nextLink?: string;
}

/** Common error representation. */
export interface ErrorModel {
  /** Error code. */
  code?: string;
  /** Error message. */
  message?: string;
  /** Error target. */
  target?: string;
  /** Error details. */
  details?: ErrorDetails[];
  /** Inner error message. */
  innerError?: string;
}

/** An error response from the service. */
export interface CloudError {
  /** Cloud error body. */
  error?: CloudErrorBody;
}

/** An error response from the service. */
export interface CloudErrorBody {
  /** An identifier for the error. Codes are invariant and are intended to be consumed programmatically. */
  code?: string;
  /** A message describing the error, intended to be suitable for display in a user interface. */
  message?: string;
  /** The target of the particular error. For example, the name of the property in error. */
  target?: string;
  /** A list of additional details about the error. */
  details?: CloudErrorBody[];
}

/** The response body contains the status of the specified asynchronous operation, indicating whether it has succeeded, is in progress, or has failed. Note that this status is distinct from the HTTP status code returned for the Get Operation Status operation itself. If the asynchronous operation succeeded, the response body includes the HTTP status code for the successful request. If the asynchronous operation failed, the response body includes the HTTP status code for the failed request and error information regarding the failure. */
export interface AzureAsyncOperationResult {
  /** Status of the Azure async operation. */
  status?: NetworkOperationStatus;
  /** Details of the error occurred during specified asynchronous operation. */
  error?: ErrorModel;
}

/** Proxy resource representation. */
export interface ProxyResource {
  /**
   * Resource ID.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly id?: string;
  /**
   * Resource name.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly name?: string;
  /**
   * Resource type.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly type?: string;
  /**
   * A unique read-only string that changes whenever the resource is updated.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly etag?: string;
}

/** Metadata pertaining to creation and last modification of the resource. */
export interface SystemData {
  /** The identity that created the resource. */
  createdBy?: string;
  /** The type of identity that created the resource. */
  createdByType?: CreatedByType;
  /** The timestamp of resource creation (UTC). */
  createdAt?: Date;
  /** The identity that last modified the resource. */
  lastModifiedBy?: string;
  /** The type of identity that last modified the resource. */
  lastModifiedByType?: CreatedByType;
  /** The type of identity that last modified the resource. */
  lastModifiedAt?: Date;
}

/** Identity for the resource. */
export interface ManagedServiceIdentity {
  /**
   * The principal id of the system assigned identity. This property will only be provided for a system assigned identity.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly principalId?: string;
  /**
   * The tenant id of the system assigned identity. This property will only be provided for a system assigned identity.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly tenantId?: string;
  /** The type of identity used for the resource. The type 'SystemAssigned, UserAssigned' includes both an implicitly created identity and a set of user assigned identities. The type 'None' will remove any identities from the virtual machine. */
  type?: ResourceIdentityType;
  /** The list of user identities associated with resource. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'. */
  userAssignedIdentities?: {
    [propertyName: string]: Components1Jq1T4ISchemasManagedserviceidentityPropertiesUserassignedidentitiesAdditionalproperties;
  };
}

export interface Components1Jq1T4ISchemasManagedserviceidentityPropertiesUserassignedidentitiesAdditionalproperties {
  /**
   * The principal id of user assigned identity.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly principalId?: string;
  /**
   * The client id of user assigned identity.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly clientId?: string;
}

/** ExtendedLocation complex type. */
export interface ExtendedLocation {
  /** The name of the extended location. */
  name?: string;
  /** The type of the extended location. */
  type?: ExtendedLocationTypes;
}

/** Response for ListSecurityRule API service call. Retrieves all security rules that belongs to a network security group. */
export interface SecurityRuleListResult {
  /** The security rules in a network security group. */
  value?: SecurityRule[];
  /** The URL to get the next set of results. */
  nextLink?: string;
}

/** Network watcher in a resource group. */
export interface NetworkWatcher extends Resource {
  /**
   * A unique read-only string that changes whenever the resource is updated.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly etag?: string;
  /**
   * The provisioning state of the network watcher resource.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly provisioningState?: ProvisioningState;
}

/** An application security group in a resource group. */
export interface ApplicationSecurityGroup extends Resource {
  /**
   * A unique read-only string that changes whenever the resource is updated.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly etag?: string;
  /**
   * The resource GUID property of the application security group resource. It uniquely identifies a resource, even if the user changes its name or migrate the resource across subscriptions or resource groups.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly resourceGuid?: string;
  /**
   * The provisioning state of the application security group resource.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly provisioningState?: ProvisioningState;
}

/** A flow log resource. */
export interface FlowLog extends Resource {
  /**
   * A unique read-only string that changes whenever the resource is updated.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly etag?: string;
  /** ID of network security group to which flow log will be applied. */
  targetResourceId?: string;
  /**
   * Guid of network security group to which flow log will be applied.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly targetResourceGuid?: string;
  /** ID of the storage account which is used to store the flow log. */
  storageId?: string;
  /** Flag to enable/disable flow logging. */
  enabled?: boolean;
  /** Parameters that define the retention policy for flow log. */
  retentionPolicy?: RetentionPolicyParameters;
  /** Parameters that define the flow log format. */
  format?: FlowLogFormatParameters;
  /** Parameters that define the configuration of traffic analytics. */
  flowAnalyticsConfiguration?: TrafficAnalyticsProperties;
  /**
   * The provisioning state of the flow log.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly provisioningState?: ProvisioningState;
}

/** Network security rule. */
export interface SecurityRule extends SubResource {
  /** The name of the resource that is unique within a resource group. This name can be used to access the resource. */
  name?: string;
  /**
   * A unique read-only string that changes whenever the resource is updated.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly etag?: string;
  /** The type of the resource. */
  type?: string;
  /** A description for this rule. Restricted to 140 chars. */
  description?: string;
  /** Network protocol this rule applies to. */
  protocol?: SecurityRuleProtocol;
  /** The source port or range. Integer or range between 0 and 65535. Asterisk '*' can also be used to match all ports. */
  sourcePortRange?: string;
  /** The destination port or range. Integer or range between 0 and 65535. Asterisk '*' can also be used to match all ports. */
  destinationPortRange?: string;
  /** The CIDR or source IP range. Asterisk '*' can also be used to match all source IPs. Default tags such as 'VirtualNetwork', 'AzureLoadBalancer' and 'Internet' can also be used. If this is an ingress rule, specifies where network traffic originates from. */
  sourceAddressPrefix?: string;
  /** The CIDR or source IP ranges. */
  sourceAddressPrefixes?: string[];
  /** The application security group specified as source. */
  sourceApplicationSecurityGroups?: ApplicationSecurityGroup[];
  /** The destination address prefix. CIDR or destination IP range. Asterisk '*' can also be used to match all source IPs. Default tags such as 'VirtualNetwork', 'AzureLoadBalancer' and 'Internet' can also be used. */
  destinationAddressPrefix?: string;
  /** The destination address prefixes. CIDR or destination IP ranges. */
  destinationAddressPrefixes?: string[];
  /** The application security group specified as destination. */
  destinationApplicationSecurityGroups?: ApplicationSecurityGroup[];
  /** The source port ranges. */
  sourcePortRanges?: string[];
  /** The destination port ranges. */
  destinationPortRanges?: string[];
  /** The network traffic is allowed or denied. */
  access?: SecurityRuleAccess;
  /** The priority of the rule. The value can be between 100 and 4096. The priority number must be unique for each rule in the collection. The lower the priority number, the higher the priority of the rule. */
  priority?: number;
  /** The direction of the rule. The direction specifies if rule will be evaluated on incoming or outgoing traffic. */
  direction?: SecurityRuleDirection;
  /**
   * The provisioning state of the security rule resource.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly provisioningState?: ProvisioningState;
}

/** The properties of a packet capture session. */
export interface PacketCaptureResultProperties extends PacketCaptureParameters {
  /**
   * The provisioning state of the packet capture session.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly provisioningState?: ProvisioningState;
}

/** Describes the properties of a connection monitor. */
export interface ConnectionMonitorResultProperties
  extends ConnectionMonitorParameters {
  /**
   * The provisioning state of the connection monitor.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly provisioningState?: ProvisioningState;
  /**
   * The date and time when the connection monitor was started.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly startTime?: Date;
  /**
   * The monitoring status of the connection monitor.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly monitoringStatus?: string;
  /**
   * Type of connection monitor.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly connectionMonitorType?: ConnectionMonitorType;
}

/** Known values of {@link ProvisioningState} that the service accepts. */
export enum KnownProvisioningState {
  /** Succeeded */
  Succeeded = "Succeeded",
  /** Updating */
  Updating = "Updating",
  /** Deleting */
  Deleting = "Deleting",
  /** Failed */
  Failed = "Failed"
}

/**
 * Defines values for ProvisioningState. \
 * {@link KnownProvisioningState} can be used interchangeably with ProvisioningState,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Succeeded** \
 * **Updating** \
 * **Deleting** \
 * **Failed**
 */
export type ProvisioningState = string;

/** Known values of {@link AssociationType} that the service accepts. */
export enum KnownAssociationType {
  /** Associated */
  Associated = "Associated",
  /** Contains */
  Contains = "Contains"
}

/**
 * Defines values for AssociationType. \
 * {@link KnownAssociationType} can be used interchangeably with AssociationType,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Associated** \
 * **Contains**
 */
export type AssociationType = string;

/** Known values of {@link Direction} that the service accepts. */
export enum KnownDirection {
  /** Inbound */
  Inbound = "Inbound",
  /** Outbound */
  Outbound = "Outbound"
}

/**
 * Defines values for Direction. \
 * {@link KnownDirection} can be used interchangeably with Direction,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Inbound** \
 * **Outbound**
 */
export type Direction = string;

/** Known values of {@link IpFlowProtocol} that the service accepts. */
export enum KnownIpFlowProtocol {
  /** TCP */
  TCP = "TCP",
  /** UDP */
  UDP = "UDP"
}

/**
 * Defines values for IpFlowProtocol. \
 * {@link KnownIpFlowProtocol} can be used interchangeably with IpFlowProtocol,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **TCP** \
 * **UDP**
 */
export type IpFlowProtocol = string;

/** Known values of {@link Access} that the service accepts. */
export enum KnownAccess {
  /** Allow */
  Allow = "Allow",
  /** Deny */
  Deny = "Deny"
}

/**
 * Defines values for Access. \
 * {@link KnownAccess} can be used interchangeably with Access,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Allow** \
 * **Deny**
 */
export type Access = string;

/** Known values of {@link NextHopType} that the service accepts. */
export enum KnownNextHopType {
  /** Internet */
  Internet = "Internet",
  /** VirtualAppliance */
  VirtualAppliance = "VirtualAppliance",
  /** VirtualNetworkGateway */
  VirtualNetworkGateway = "VirtualNetworkGateway",
  /** VnetLocal */
  VnetLocal = "VnetLocal",
  /** HyperNetGateway */
  HyperNetGateway = "HyperNetGateway",
  /** None */
  None = "None"
}

/**
 * Defines values for NextHopType. \
 * {@link KnownNextHopType} can be used interchangeably with NextHopType,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Internet** \
 * **VirtualAppliance** \
 * **VirtualNetworkGateway** \
 * **VnetLocal** \
 * **HyperNetGateway** \
 * **None**
 */
export type NextHopType = string;

/** Known values of {@link SecurityRuleProtocol} that the service accepts. */
export enum KnownSecurityRuleProtocol {
  /** Tcp */
  Tcp = "Tcp",
  /** Udp */
  Udp = "Udp",
  /** Icmp */
  Icmp = "Icmp",
  /** Esp */
  Esp = "Esp",
  /** Asterisk */
  Asterisk = "*",
  /** Ah */
  Ah = "Ah"
}

/**
 * Defines values for SecurityRuleProtocol. \
 * {@link KnownSecurityRuleProtocol} can be used interchangeably with SecurityRuleProtocol,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Tcp** \
 * **Udp** \
 * **Icmp** \
 * **Esp** \
 * ***** \
 * **Ah**
 */
export type SecurityRuleProtocol = string;

/** Known values of {@link SecurityRuleAccess} that the service accepts. */
export enum KnownSecurityRuleAccess {
  /** Allow */
  Allow = "Allow",
  /** Deny */
  Deny = "Deny"
}

/**
 * Defines values for SecurityRuleAccess. \
 * {@link KnownSecurityRuleAccess} can be used interchangeably with SecurityRuleAccess,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Allow** \
 * **Deny**
 */
export type SecurityRuleAccess = string;

/** Known values of {@link SecurityRuleDirection} that the service accepts. */
export enum KnownSecurityRuleDirection {
  /** Inbound */
  Inbound = "Inbound",
  /** Outbound */
  Outbound = "Outbound"
}

/**
 * Defines values for SecurityRuleDirection. \
 * {@link KnownSecurityRuleDirection} can be used interchangeably with SecurityRuleDirection,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Inbound** \
 * **Outbound**
 */
export type SecurityRuleDirection = string;

/** Known values of {@link EffectiveSecurityRuleProtocol} that the service accepts. */
export enum KnownEffectiveSecurityRuleProtocol {
  /** Tcp */
  Tcp = "Tcp",
  /** Udp */
  Udp = "Udp",
  /** All */
  All = "All"
}

/**
 * Defines values for EffectiveSecurityRuleProtocol. \
 * {@link KnownEffectiveSecurityRuleProtocol} can be used interchangeably with EffectiveSecurityRuleProtocol,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Tcp** \
 * **Udp** \
 * **All**
 */
export type EffectiveSecurityRuleProtocol = string;

/** Known values of {@link PcProtocol} that the service accepts. */
export enum KnownPcProtocol {
  /** TCP */
  TCP = "TCP",
  /** UDP */
  UDP = "UDP",
  /** Any */
  Any = "Any"
}

/**
 * Defines values for PcProtocol. \
 * {@link KnownPcProtocol} can be used interchangeably with PcProtocol,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **TCP** \
 * **UDP** \
 * **Any**
 */
export type PcProtocol = string;

/** Known values of {@link PcStatus} that the service accepts. */
export enum KnownPcStatus {
  /** NotStarted */
  NotStarted = "NotStarted",
  /** Running */
  Running = "Running",
  /** Stopped */
  Stopped = "Stopped",
  /** Error */
  Error = "Error",
  /** Unknown */
  Unknown = "Unknown"
}

/**
 * Defines values for PcStatus. \
 * {@link KnownPcStatus} can be used interchangeably with PcStatus,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **NotStarted** \
 * **Running** \
 * **Stopped** \
 * **Error** \
 * **Unknown**
 */
export type PcStatus = string;

/** Known values of {@link PcError} that the service accepts. */
export enum KnownPcError {
  /** InternalError */
  InternalError = "InternalError",
  /** AgentStopped */
  AgentStopped = "AgentStopped",
  /** CaptureFailed */
  CaptureFailed = "CaptureFailed",
  /** LocalFileFailed */
  LocalFileFailed = "LocalFileFailed",
  /** StorageFailed */
  StorageFailed = "StorageFailed"
}

/**
 * Defines values for PcError. \
 * {@link KnownPcError} can be used interchangeably with PcError,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **InternalError** \
 * **AgentStopped** \
 * **CaptureFailed** \
 * **LocalFileFailed** \
 * **StorageFailed**
 */
export type PcError = string;

/** Known values of {@link FlowLogFormatType} that the service accepts. */
export enum KnownFlowLogFormatType {
  /** Json */
  Json = "JSON"
}

/**
 * Defines values for FlowLogFormatType. \
 * {@link KnownFlowLogFormatType} can be used interchangeably with FlowLogFormatType,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **JSON**
 */
export type FlowLogFormatType = string;

/** Known values of {@link Protocol} that the service accepts. */
export enum KnownProtocol {
  /** Tcp */
  Tcp = "Tcp",
  /** Http */
  Http = "Http",
  /** Https */
  Https = "Https",
  /** Icmp */
  Icmp = "Icmp"
}

/**
 * Defines values for Protocol. \
 * {@link KnownProtocol} can be used interchangeably with Protocol,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Tcp** \
 * **Http** \
 * **Https** \
 * **Icmp**
 */
export type Protocol = string;

/** Known values of {@link HttpMethod} that the service accepts. */
export enum KnownHttpMethod {
  /** Get */
  Get = "Get"
}

/**
 * Defines values for HttpMethod. \
 * {@link KnownHttpMethod} can be used interchangeably with HttpMethod,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Get**
 */
export type HttpMethod = string;

/** Known values of {@link IPVersion} that the service accepts. */
export enum KnownIPVersion {
  /** IPv4 */
  IPv4 = "IPv4",
  /** IPv6 */
  IPv6 = "IPv6"
}

/**
 * Defines values for IPVersion. \
 * {@link KnownIPVersion} can be used interchangeably with IPVersion,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **IPv4** \
 * **IPv6**
 */
export type IPVersion = string;

/** Known values of {@link Origin} that the service accepts. */
export enum KnownOrigin {
  /** Local */
  Local = "Local",
  /** Inbound */
  Inbound = "Inbound",
  /** Outbound */
  Outbound = "Outbound"
}

/**
 * Defines values for Origin. \
 * {@link KnownOrigin} can be used interchangeably with Origin,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Local** \
 * **Inbound** \
 * **Outbound**
 */
export type Origin = string;

/** Known values of {@link Severity} that the service accepts. */
export enum KnownSeverity {
  /** Error */
  Error = "Error",
  /** Warning */
  Warning = "Warning"
}

/**
 * Defines values for Severity. \
 * {@link KnownSeverity} can be used interchangeably with Severity,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Error** \
 * **Warning**
 */
export type Severity = string;

/** Known values of {@link IssueType} that the service accepts. */
export enum KnownIssueType {
  /** Unknown */
  Unknown = "Unknown",
  /** AgentStopped */
  AgentStopped = "AgentStopped",
  /** GuestFirewall */
  GuestFirewall = "GuestFirewall",
  /** DnsResolution */
  DnsResolution = "DnsResolution",
  /** SocketBind */
  SocketBind = "SocketBind",
  /** NetworkSecurityRule */
  NetworkSecurityRule = "NetworkSecurityRule",
  /** UserDefinedRoute */
  UserDefinedRoute = "UserDefinedRoute",
  /** PortThrottled */
  PortThrottled = "PortThrottled",
  /** Platform */
  Platform = "Platform"
}

/**
 * Defines values for IssueType. \
 * {@link KnownIssueType} can be used interchangeably with IssueType,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Unknown** \
 * **AgentStopped** \
 * **GuestFirewall** \
 * **DnsResolution** \
 * **SocketBind** \
 * **NetworkSecurityRule** \
 * **UserDefinedRoute** \
 * **PortThrottled** \
 * **Platform**
 */
export type IssueType = string;

/** Known values of {@link ConnectionStatus} that the service accepts. */
export enum KnownConnectionStatus {
  /** Unknown */
  Unknown = "Unknown",
  /** Connected */
  Connected = "Connected",
  /** Disconnected */
  Disconnected = "Disconnected",
  /** Degraded */
  Degraded = "Degraded"
}

/**
 * Defines values for ConnectionStatus. \
 * {@link KnownConnectionStatus} can be used interchangeably with ConnectionStatus,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Unknown** \
 * **Connected** \
 * **Disconnected** \
 * **Degraded**
 */
export type ConnectionStatus = string;

/** Known values of {@link VerbosityLevel} that the service accepts. */
export enum KnownVerbosityLevel {
  /** Normal */
  Normal = "Normal",
  /** Minimum */
  Minimum = "Minimum",
  /** Full */
  Full = "Full"
}

/**
 * Defines values for VerbosityLevel. \
 * {@link KnownVerbosityLevel} can be used interchangeably with VerbosityLevel,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Normal** \
 * **Minimum** \
 * **Full**
 */
export type VerbosityLevel = string;

/** Known values of {@link EndpointType} that the service accepts. */
export enum KnownEndpointType {
  /** AzureVM */
  AzureVM = "AzureVM",
  /** AzureVNet */
  AzureVNet = "AzureVNet",
  /** AzureSubnet */
  AzureSubnet = "AzureSubnet",
  /** ExternalAddress */
  ExternalAddress = "ExternalAddress",
  /** MMAWorkspaceMachine */
  MMAWorkspaceMachine = "MMAWorkspaceMachine",
  /** MMAWorkspaceNetwork */
  MMAWorkspaceNetwork = "MMAWorkspaceNetwork",
  /** AzureArcVM */
  AzureArcVM = "AzureArcVM",
  /** AzureVmss */
  AzureVmss = "AzureVMSS",
  /** AzureArcNetwork */
  AzureArcNetwork = "AzureArcNetwork"
}

/**
 * Defines values for EndpointType. \
 * {@link KnownEndpointType} can be used interchangeably with EndpointType,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **AzureVM** \
 * **AzureVNet** \
 * **AzureSubnet** \
 * **ExternalAddress** \
 * **MMAWorkspaceMachine** \
 * **MMAWorkspaceNetwork** \
 * **AzureArcVM** \
 * **AzureVMSS** \
 * **AzureArcNetwork**
 */
export type EndpointType = string;

/** Known values of {@link ConnectionMonitorEndpointFilterType} that the service accepts. */
export enum KnownConnectionMonitorEndpointFilterType {
  /** Include */
  Include = "Include"
}

/**
 * Defines values for ConnectionMonitorEndpointFilterType. \
 * {@link KnownConnectionMonitorEndpointFilterType} can be used interchangeably with ConnectionMonitorEndpointFilterType,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Include**
 */
export type ConnectionMonitorEndpointFilterType = string;

/** Known values of {@link ConnectionMonitorEndpointFilterItemType} that the service accepts. */
export enum KnownConnectionMonitorEndpointFilterItemType {
  /** AgentAddress */
  AgentAddress = "AgentAddress"
}

/**
 * Defines values for ConnectionMonitorEndpointFilterItemType. \
 * {@link KnownConnectionMonitorEndpointFilterItemType} can be used interchangeably with ConnectionMonitorEndpointFilterItemType,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **AgentAddress**
 */
export type ConnectionMonitorEndpointFilterItemType = string;

/** Known values of {@link CoverageLevel} that the service accepts. */
export enum KnownCoverageLevel {
  /** Default */
  Default = "Default",
  /** Low */
  Low = "Low",
  /** BelowAverage */
  BelowAverage = "BelowAverage",
  /** Average */
  Average = "Average",
  /** AboveAverage */
  AboveAverage = "AboveAverage",
  /** Full */
  Full = "Full"
}

/**
 * Defines values for CoverageLevel. \
 * {@link KnownCoverageLevel} can be used interchangeably with CoverageLevel,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Default** \
 * **Low** \
 * **BelowAverage** \
 * **Average** \
 * **AboveAverage** \
 * **Full**
 */
export type CoverageLevel = string;

/** Known values of {@link ConnectionMonitorTestConfigurationProtocol} that the service accepts. */
export enum KnownConnectionMonitorTestConfigurationProtocol {
  /** Tcp */
  Tcp = "Tcp",
  /** Http */
  Http = "Http",
  /** Icmp */
  Icmp = "Icmp"
}

/**
 * Defines values for ConnectionMonitorTestConfigurationProtocol. \
 * {@link KnownConnectionMonitorTestConfigurationProtocol} can be used interchangeably with ConnectionMonitorTestConfigurationProtocol,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Tcp** \
 * **Http** \
 * **Icmp**
 */
export type ConnectionMonitorTestConfigurationProtocol = string;

/** Known values of {@link PreferredIPVersion} that the service accepts. */
export enum KnownPreferredIPVersion {
  /** IPv4 */
  IPv4 = "IPv4",
  /** IPv6 */
  IPv6 = "IPv6"
}

/**
 * Defines values for PreferredIPVersion. \
 * {@link KnownPreferredIPVersion} can be used interchangeably with PreferredIPVersion,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **IPv4** \
 * **IPv6**
 */
export type PreferredIPVersion = string;

/** Known values of {@link HttpConfigurationMethod} that the service accepts. */
export enum KnownHttpConfigurationMethod {
  /** Get */
  Get = "Get",
  /** Post */
  Post = "Post"
}

/**
 * Defines values for HttpConfigurationMethod. \
 * {@link KnownHttpConfigurationMethod} can be used interchangeably with HttpConfigurationMethod,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Get** \
 * **Post**
 */
export type HttpConfigurationMethod = string;

/** Known values of {@link DestinationPortBehavior} that the service accepts. */
export enum KnownDestinationPortBehavior {
  /** None */
  None = "None",
  /** ListenIfAvailable */
  ListenIfAvailable = "ListenIfAvailable"
}

/**
 * Defines values for DestinationPortBehavior. \
 * {@link KnownDestinationPortBehavior} can be used interchangeably with DestinationPortBehavior,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **None** \
 * **ListenIfAvailable**
 */
export type DestinationPortBehavior = string;

/** Known values of {@link OutputType} that the service accepts. */
export enum KnownOutputType {
  /** Workspace */
  Workspace = "Workspace"
}

/**
 * Defines values for OutputType. \
 * {@link KnownOutputType} can be used interchangeably with OutputType,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Workspace**
 */
export type OutputType = string;

/** Known values of {@link ConnectionMonitorType} that the service accepts. */
export enum KnownConnectionMonitorType {
  /** MultiEndpoint */
  MultiEndpoint = "MultiEndpoint",
  /** SingleSourceDestination */
  SingleSourceDestination = "SingleSourceDestination"
}

/**
 * Defines values for ConnectionMonitorType. \
 * {@link KnownConnectionMonitorType} can be used interchangeably with ConnectionMonitorType,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **MultiEndpoint** \
 * **SingleSourceDestination**
 */
export type ConnectionMonitorType = string;

/** Known values of {@link ConnectionMonitorSourceStatus} that the service accepts. */
export enum KnownConnectionMonitorSourceStatus {
  /** Unknown */
  Unknown = "Unknown",
  /** Active */
  Active = "Active",
  /** Inactive */
  Inactive = "Inactive"
}

/**
 * Defines values for ConnectionMonitorSourceStatus. \
 * {@link KnownConnectionMonitorSourceStatus} can be used interchangeably with ConnectionMonitorSourceStatus,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Unknown** \
 * **Active** \
 * **Inactive**
 */
export type ConnectionMonitorSourceStatus = string;

/** Known values of {@link ConnectionState} that the service accepts. */
export enum KnownConnectionState {
  /** Reachable */
  Reachable = "Reachable",
  /** Unreachable */
  Unreachable = "Unreachable",
  /** Unknown */
  Unknown = "Unknown"
}

/**
 * Defines values for ConnectionState. \
 * {@link KnownConnectionState} can be used interchangeably with ConnectionState,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Reachable** \
 * **Unreachable** \
 * **Unknown**
 */
export type ConnectionState = string;

/** Known values of {@link EvaluationState} that the service accepts. */
export enum KnownEvaluationState {
  /** NotStarted */
  NotStarted = "NotStarted",
  /** InProgress */
  InProgress = "InProgress",
  /** Completed */
  Completed = "Completed"
}

/**
 * Defines values for EvaluationState. \
 * {@link KnownEvaluationState} can be used interchangeably with EvaluationState,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **NotStarted** \
 * **InProgress** \
 * **Completed**
 */
export type EvaluationState = string;

/** Known values of {@link NetworkOperationStatus} that the service accepts. */
export enum KnownNetworkOperationStatus {
  /** InProgress */
  InProgress = "InProgress",
  /** Succeeded */
  Succeeded = "Succeeded",
  /** Failed */
  Failed = "Failed"
}

/**
 * Defines values for NetworkOperationStatus. \
 * {@link KnownNetworkOperationStatus} can be used interchangeably with NetworkOperationStatus,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **InProgress** \
 * **Succeeded** \
 * **Failed**
 */
export type NetworkOperationStatus = string;

/** Known values of {@link CreatedByType} that the service accepts. */
export enum KnownCreatedByType {
  /** User */
  User = "User",
  /** Application */
  Application = "Application",
  /** ManagedIdentity */
  ManagedIdentity = "ManagedIdentity",
  /** Key */
  Key = "Key"
}

/**
 * Defines values for CreatedByType. \
 * {@link KnownCreatedByType} can be used interchangeably with CreatedByType,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **User** \
 * **Application** \
 * **ManagedIdentity** \
 * **Key**
 */
export type CreatedByType = string;

/** Known values of {@link ExtendedLocationTypes} that the service accepts. */
export enum KnownExtendedLocationTypes {
  /** EdgeZone */
  EdgeZone = "EdgeZone"
}

/**
 * Defines values for ExtendedLocationTypes. \
 * {@link KnownExtendedLocationTypes} can be used interchangeably with ExtendedLocationTypes,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **EdgeZone**
 */
export type ExtendedLocationTypes = string;

/** Known values of {@link AuthenticationMethod} that the service accepts. */
export enum KnownAuthenticationMethod {
  /** Eaptls */
  Eaptls = "EAPTLS",
  /** EapmschaPv2 */
  EapmschaPv2 = "EAPMSCHAPv2"
}

/**
 * Defines values for AuthenticationMethod. \
 * {@link KnownAuthenticationMethod} can be used interchangeably with AuthenticationMethod,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **EAPTLS** \
 * **EAPMSCHAPv2**
 */
export type AuthenticationMethod = string;

/** Known values of {@link IPAllocationMethod} that the service accepts. */
export enum KnownIPAllocationMethod {
  /** Static */
  Static = "Static",
  /** Dynamic */
  Dynamic = "Dynamic"
}

/**
 * Defines values for IPAllocationMethod. \
 * {@link KnownIPAllocationMethod} can be used interchangeably with IPAllocationMethod,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Static** \
 * **Dynamic**
 */
export type IPAllocationMethod = string;
/** Defines values for PacketCaptureTargetType. */
export type PacketCaptureTargetType = "AzureVM" | "AzureVMSS";
/** Defines values for ResourceIdentityType. */
export type ResourceIdentityType =
  | "SystemAssigned"
  | "UserAssigned"
  | "SystemAssigned, UserAssigned"
  | "None";

/** Optional parameters. */
export interface NetworkWatchersCreateOrUpdateOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the createOrUpdate operation. */
export type NetworkWatchersCreateOrUpdateResponse = NetworkWatcher;

/** Optional parameters. */
export interface NetworkWatchersGetOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the get operation. */
export type NetworkWatchersGetResponse = NetworkWatcher;

/** Optional parameters. */
export interface NetworkWatchersDeleteOptionalParams
  extends coreClient.OperationOptions {
  /** Delay to wait until next poll, in milliseconds. */
  updateIntervalInMs?: number;
  /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
  resumeFrom?: string;
}

/** Optional parameters. */
export interface NetworkWatchersUpdateTagsOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the updateTags operation. */
export type NetworkWatchersUpdateTagsResponse = NetworkWatcher;

/** Optional parameters. */
export interface NetworkWatchersListOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the list operation. */
export type NetworkWatchersListResponse = NetworkWatcherListResult;

/** Optional parameters. */
export interface NetworkWatchersListAllOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the listAll operation. */
export type NetworkWatchersListAllResponse = NetworkWatcherListResult;

/** Optional parameters. */
export interface NetworkWatchersGetTopologyOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the getTopology operation. */
export type NetworkWatchersGetTopologyResponse = Topology;

/** Optional parameters. */
export interface NetworkWatchersVerifyIPFlowOptionalParams
  extends coreClient.OperationOptions {
  /** Delay to wait until next poll, in milliseconds. */
  updateIntervalInMs?: number;
  /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
  resumeFrom?: string;
}

/** Contains response data for the verifyIPFlow operation. */
export type NetworkWatchersVerifyIPFlowResponse = VerificationIPFlowResult;

/** Optional parameters. */
export interface NetworkWatchersGetNextHopOptionalParams
  extends coreClient.OperationOptions {
  /** Delay to wait until next poll, in milliseconds. */
  updateIntervalInMs?: number;
  /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
  resumeFrom?: string;
}

/** Contains response data for the getNextHop operation. */
export type NetworkWatchersGetNextHopResponse = NextHopResult;

/** Optional parameters. */
export interface NetworkWatchersGetVMSecurityRulesOptionalParams
  extends coreClient.OperationOptions {
  /** Delay to wait until next poll, in milliseconds. */
  updateIntervalInMs?: number;
  /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
  resumeFrom?: string;
}

/** Contains response data for the getVMSecurityRules operation. */
export type NetworkWatchersGetVMSecurityRulesResponse = SecurityGroupViewResult;

/** Optional parameters. */
export interface NetworkWatchersGetTroubleshootingOptionalParams
  extends coreClient.OperationOptions {
  /** Delay to wait until next poll, in milliseconds. */
  updateIntervalInMs?: number;
  /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
  resumeFrom?: string;
}

/** Contains response data for the getTroubleshooting operation. */
export type NetworkWatchersGetTroubleshootingResponse = TroubleshootingResult;

/** Optional parameters. */
export interface NetworkWatchersGetTroubleshootingResultOptionalParams
  extends coreClient.OperationOptions {
  /** Delay to wait until next poll, in milliseconds. */
  updateIntervalInMs?: number;
  /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
  resumeFrom?: string;
}

/** Contains response data for the getTroubleshootingResult operation. */
export type NetworkWatchersGetTroubleshootingResultResponse = TroubleshootingResult;

/** Optional parameters. */
export interface NetworkWatchersSetFlowLogConfigurationOptionalParams
  extends coreClient.OperationOptions {
  /** Delay to wait until next poll, in milliseconds. */
  updateIntervalInMs?: number;
  /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
  resumeFrom?: string;
}

/** Contains response data for the setFlowLogConfiguration operation. */
export type NetworkWatchersSetFlowLogConfigurationResponse = FlowLogInformation;

/** Optional parameters. */
export interface NetworkWatchersGetFlowLogStatusOptionalParams
  extends coreClient.OperationOptions {
  /** Delay to wait until next poll, in milliseconds. */
  updateIntervalInMs?: number;
  /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
  resumeFrom?: string;
}

/** Contains response data for the getFlowLogStatus operation. */
export type NetworkWatchersGetFlowLogStatusResponse = FlowLogInformation;

/** Optional parameters. */
export interface NetworkWatchersCheckConnectivityOptionalParams
  extends coreClient.OperationOptions {
  /** Delay to wait until next poll, in milliseconds. */
  updateIntervalInMs?: number;
  /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
  resumeFrom?: string;
}

/** Contains response data for the checkConnectivity operation. */
export type NetworkWatchersCheckConnectivityResponse = ConnectivityInformation;

/** Optional parameters. */
export interface NetworkWatchersGetAzureReachabilityReportOptionalParams
  extends coreClient.OperationOptions {
  /** Delay to wait until next poll, in milliseconds. */
  updateIntervalInMs?: number;
  /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
  resumeFrom?: string;
}

/** Contains response data for the getAzureReachabilityReport operation. */
export type NetworkWatchersGetAzureReachabilityReportResponse = AzureReachabilityReport;

/** Optional parameters. */
export interface NetworkWatchersListAvailableProvidersOptionalParams
  extends coreClient.OperationOptions {
  /** Delay to wait until next poll, in milliseconds. */
  updateIntervalInMs?: number;
  /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
  resumeFrom?: string;
}

/** Contains response data for the listAvailableProviders operation. */
export type NetworkWatchersListAvailableProvidersResponse = AvailableProvidersList;

/** Optional parameters. */
export interface NetworkWatchersGetNetworkConfigurationDiagnosticOptionalParams
  extends coreClient.OperationOptions {
  /** Delay to wait until next poll, in milliseconds. */
  updateIntervalInMs?: number;
  /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
  resumeFrom?: string;
}

/** Contains response data for the getNetworkConfigurationDiagnostic operation. */
export type NetworkWatchersGetNetworkConfigurationDiagnosticResponse = NetworkConfigurationDiagnosticResponse;

/** Optional parameters. */
export interface PacketCapturesCreateOptionalParams
  extends coreClient.OperationOptions {
  /** Delay to wait until next poll, in milliseconds. */
  updateIntervalInMs?: number;
  /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
  resumeFrom?: string;
}

/** Contains response data for the create operation. */
export type PacketCapturesCreateResponse = PacketCaptureResult;

/** Optional parameters. */
export interface PacketCapturesGetOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the get operation. */
export type PacketCapturesGetResponse = PacketCaptureResult;

/** Optional parameters. */
export interface PacketCapturesDeleteOptionalParams
  extends coreClient.OperationOptions {
  /** Delay to wait until next poll, in milliseconds. */
  updateIntervalInMs?: number;
  /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
  resumeFrom?: string;
}

/** Optional parameters. */
export interface PacketCapturesStopOptionalParams
  extends coreClient.OperationOptions {
  /** Delay to wait until next poll, in milliseconds. */
  updateIntervalInMs?: number;
  /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
  resumeFrom?: string;
}

/** Optional parameters. */
export interface PacketCapturesGetStatusOptionalParams
  extends coreClient.OperationOptions {
  /** Delay to wait until next poll, in milliseconds. */
  updateIntervalInMs?: number;
  /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
  resumeFrom?: string;
}

/** Contains response data for the getStatus operation. */
export type PacketCapturesGetStatusResponse = PacketCaptureQueryStatusResult;

/** Optional parameters. */
export interface PacketCapturesListOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the list operation. */
export type PacketCapturesListResponse = PacketCaptureListResult;

/** Optional parameters. */
export interface ConnectionMonitorsCreateOrUpdateOptionalParams
  extends coreClient.OperationOptions {
  /** Value indicating whether connection monitor V1 should be migrated to V2 format. */
  migrate?: string;
  /** Delay to wait until next poll, in milliseconds. */
  updateIntervalInMs?: number;
  /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
  resumeFrom?: string;
}

/** Contains response data for the createOrUpdate operation. */
export type ConnectionMonitorsCreateOrUpdateResponse = ConnectionMonitorResult;

/** Optional parameters. */
export interface ConnectionMonitorsGetOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the get operation. */
export type ConnectionMonitorsGetResponse = ConnectionMonitorResult;

/** Optional parameters. */
export interface ConnectionMonitorsDeleteOptionalParams
  extends coreClient.OperationOptions {
  /** Delay to wait until next poll, in milliseconds. */
  updateIntervalInMs?: number;
  /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
  resumeFrom?: string;
}

/** Optional parameters. */
export interface ConnectionMonitorsUpdateTagsOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the updateTags operation. */
export type ConnectionMonitorsUpdateTagsResponse = ConnectionMonitorResult;

/** Optional parameters. */
export interface ConnectionMonitorsStopOptionalParams
  extends coreClient.OperationOptions {
  /** Delay to wait until next poll, in milliseconds. */
  updateIntervalInMs?: number;
  /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
  resumeFrom?: string;
}

/** Optional parameters. */
export interface ConnectionMonitorsStartOptionalParams
  extends coreClient.OperationOptions {
  /** Delay to wait until next poll, in milliseconds. */
  updateIntervalInMs?: number;
  /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
  resumeFrom?: string;
}

/** Optional parameters. */
export interface ConnectionMonitorsQueryOptionalParams
  extends coreClient.OperationOptions {
  /** Delay to wait until next poll, in milliseconds. */
  updateIntervalInMs?: number;
  /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
  resumeFrom?: string;
}

/** Contains response data for the query operation. */
export type ConnectionMonitorsQueryResponse = ConnectionMonitorQueryResult;

/** Optional parameters. */
export interface ConnectionMonitorsListOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the list operation. */
export type ConnectionMonitorsListResponse = ConnectionMonitorListResult;

/** Optional parameters. */
export interface FlowLogsCreateOrUpdateOptionalParams
  extends coreClient.OperationOptions {
  /** Delay to wait until next poll, in milliseconds. */
  updateIntervalInMs?: number;
  /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
  resumeFrom?: string;
}

/** Contains response data for the createOrUpdate operation. */
export type FlowLogsCreateOrUpdateResponse = FlowLog;

/** Optional parameters. */
export interface FlowLogsUpdateTagsOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the updateTags operation. */
export type FlowLogsUpdateTagsResponse = FlowLog;

/** Optional parameters. */
export interface FlowLogsGetOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the get operation. */
export type FlowLogsGetResponse = FlowLog;

/** Optional parameters. */
export interface FlowLogsDeleteOptionalParams
  extends coreClient.OperationOptions {
  /** Delay to wait until next poll, in milliseconds. */
  updateIntervalInMs?: number;
  /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
  resumeFrom?: string;
}

/** Optional parameters. */
export interface FlowLogsListOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the list operation. */
export type FlowLogsListResponse = FlowLogListResult;

/** Optional parameters. */
export interface FlowLogsListNextOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the listNext operation. */
export type FlowLogsListNextResponse = FlowLogListResult;

/** Optional parameters. */
export interface NetworkManagementClientOptionalParams
  extends coreClient.ServiceClientOptions {
  /** server parameter */
  $host?: string;
  /** Api Version */
  apiVersion?: string;
  /** Overrides client endpoint. */
  endpoint?: string;
}
