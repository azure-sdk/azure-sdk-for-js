## API Report File for "@azure/arm-network"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import * as coreAuth from '@azure/core-auth';
import * as coreClient from '@azure/core-client';
import { OperationState } from '@azure/core-lro';
import { PagedAsyncIterableIterator } from '@azure/core-paging';
import { SimplePollerLike } from '@azure/core-lro';

// @public
export type Access = string;

// @public
export interface ApplicationSecurityGroup extends Resource {
    readonly etag?: string;
    readonly provisioningState?: ProvisioningState;
    readonly resourceGuid?: string;
}

// @public
export type AssociationType = string;

// @public
export type AuthenticationMethod = string;

// @public
export interface AvailableProvidersList {
    countries: AvailableProvidersListCountry[];
}

// @public
export interface AvailableProvidersListCity {
    cityName?: string;
    providers?: string[];
}

// @public
export interface AvailableProvidersListCountry {
    countryName?: string;
    providers?: string[];
    states?: AvailableProvidersListState[];
}

// @public
export interface AvailableProvidersListParameters {
    azureLocations?: string[];
    city?: string;
    country?: string;
    state?: string;
}

// @public
export interface AvailableProvidersListState {
    cities?: AvailableProvidersListCity[];
    providers?: string[];
    stateName?: string;
}

// @public
export interface AzureAsyncOperationResult {
    error?: ErrorModel;
    status?: NetworkOperationStatus;
}

// @public
export interface AzureReachabilityReport {
    aggregationLevel: string;
    providerLocation: AzureReachabilityReportLocation;
    reachabilityReport: AzureReachabilityReportItem[];
}

// @public
export interface AzureReachabilityReportItem {
    azureLocation?: string;
    latencies?: AzureReachabilityReportLatencyInfo[];
    provider?: string;
}

// @public
export interface AzureReachabilityReportLatencyInfo {
    score?: number;
    timeStamp?: Date;
}

// @public
export interface AzureReachabilityReportLocation {
    city?: string;
    country: string;
    state?: string;
}

// @public
export interface AzureReachabilityReportParameters {
    azureLocations?: string[];
    endTime: Date;
    providerLocation: AzureReachabilityReportLocation;
    providers?: string[];
    startTime: Date;
}

// @public
export interface CloudError {
    error?: CloudErrorBody;
}

// @public
export interface CloudErrorBody {
    code?: string;
    details?: CloudErrorBody[];
    message?: string;
    target?: string;
}

// @public (undocumented)
export interface Components1Jq1T4ISchemasManagedserviceidentityPropertiesUserassignedidentitiesAdditionalproperties {
    readonly clientId?: string;
    readonly principalId?: string;
}

// @public
export interface ConnectionMonitor {
    autoStart?: boolean;
    destination?: ConnectionMonitorDestination;
    endpoints?: ConnectionMonitorEndpoint[];
    location?: string;
    monitoringIntervalInSeconds?: number;
    notes?: string;
    outputs?: ConnectionMonitorOutput[];
    source?: ConnectionMonitorSource;
    tags?: {
        [propertyName: string]: string;
    };
    testConfigurations?: ConnectionMonitorTestConfiguration[];
    testGroups?: ConnectionMonitorTestGroup[];
}

// @public
export interface ConnectionMonitorDestination {
    address?: string;
    port?: number;
    resourceId?: string;
}

// @public
export interface ConnectionMonitorEndpoint {
    address?: string;
    coverageLevel?: CoverageLevel;
    filter?: ConnectionMonitorEndpointFilter;
    locationDetails?: ConnectionMonitorEndpointLocationDetails;
    name: string;
    resourceId?: string;
    scope?: ConnectionMonitorEndpointScope;
    subscriptionId?: string;
    type?: EndpointType;
}

// @public
export interface ConnectionMonitorEndpointFilter {
    items?: ConnectionMonitorEndpointFilterItem[];
    type?: ConnectionMonitorEndpointFilterType;
}

// @public
export interface ConnectionMonitorEndpointFilterItem {
    address?: string;
    type?: ConnectionMonitorEndpointFilterItemType;
}

// @public
export type ConnectionMonitorEndpointFilterItemType = string;

// @public
export type ConnectionMonitorEndpointFilterType = string;

// @public
export interface ConnectionMonitorEndpointLocationDetails {
    region?: string;
}

// @public
export interface ConnectionMonitorEndpointScope {
    exclude?: ConnectionMonitorEndpointScopeItem[];
    include?: ConnectionMonitorEndpointScopeItem[];
}

// @public
export interface ConnectionMonitorEndpointScopeItem {
    address?: string;
}

// @public
export interface ConnectionMonitorHttpConfiguration {
    method?: HttpConfigurationMethod;
    path?: string;
    port?: number;
    preferHttps?: boolean;
    requestHeaders?: HttpHeader[];
    validStatusCodeRanges?: string[];
}

// @public
export interface ConnectionMonitorIcmpConfiguration {
    disableTraceRoute?: boolean;
}

// @public
export interface ConnectionMonitorListResult {
    value?: ConnectionMonitorResult[];
}

// @public
export interface ConnectionMonitorOutput {
    type?: OutputType;
    workspaceSettings?: ConnectionMonitorWorkspaceSettings;
}

// @public
export interface ConnectionMonitorParameters {
    autoStart?: boolean;
    destination?: ConnectionMonitorDestination;
    endpoints?: ConnectionMonitorEndpoint[];
    monitoringIntervalInSeconds?: number;
    notes?: string;
    outputs?: ConnectionMonitorOutput[];
    source?: ConnectionMonitorSource;
    testConfigurations?: ConnectionMonitorTestConfiguration[];
    testGroups?: ConnectionMonitorTestGroup[];
}

// @public
export interface ConnectionMonitorQueryResult {
    sourceStatus?: ConnectionMonitorSourceStatus;
    states?: ConnectionStateSnapshot[];
}

// @public
export interface ConnectionMonitorResult {
    autoStart?: boolean;
    readonly connectionMonitorType?: ConnectionMonitorType;
    destination?: ConnectionMonitorDestination;
    endpoints?: ConnectionMonitorEndpoint[];
    readonly etag?: string;
    readonly id?: string;
    location?: string;
    monitoringIntervalInSeconds?: number;
    readonly monitoringStatus?: string;
    readonly name?: string;
    notes?: string;
    outputs?: ConnectionMonitorOutput[];
    readonly provisioningState?: ProvisioningState;
    source?: ConnectionMonitorSource;
    readonly startTime?: Date;
    tags?: {
        [propertyName: string]: string;
    };
    testConfigurations?: ConnectionMonitorTestConfiguration[];
    testGroups?: ConnectionMonitorTestGroup[];
    readonly type?: string;
}

// @public
export interface ConnectionMonitorResultProperties extends ConnectionMonitorParameters {
    readonly connectionMonitorType?: ConnectionMonitorType;
    readonly monitoringStatus?: string;
    readonly provisioningState?: ProvisioningState;
    readonly startTime?: Date;
}

// @public
export interface ConnectionMonitors {
    beginCreateOrUpdate(resourceGroupName: string, networkWatcherName: string, connectionMonitorName: string, parameters: ConnectionMonitor, options?: ConnectionMonitorsCreateOrUpdateOptionalParams): Promise<SimplePollerLike<OperationState<ConnectionMonitorsCreateOrUpdateResponse>, ConnectionMonitorsCreateOrUpdateResponse>>;
    beginCreateOrUpdateAndWait(resourceGroupName: string, networkWatcherName: string, connectionMonitorName: string, parameters: ConnectionMonitor, options?: ConnectionMonitorsCreateOrUpdateOptionalParams): Promise<ConnectionMonitorsCreateOrUpdateResponse>;
    beginDelete(resourceGroupName: string, networkWatcherName: string, connectionMonitorName: string, options?: ConnectionMonitorsDeleteOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    beginDeleteAndWait(resourceGroupName: string, networkWatcherName: string, connectionMonitorName: string, options?: ConnectionMonitorsDeleteOptionalParams): Promise<void>;
    beginQuery(resourceGroupName: string, networkWatcherName: string, connectionMonitorName: string, options?: ConnectionMonitorsQueryOptionalParams): Promise<SimplePollerLike<OperationState<ConnectionMonitorsQueryResponse>, ConnectionMonitorsQueryResponse>>;
    beginQueryAndWait(resourceGroupName: string, networkWatcherName: string, connectionMonitorName: string, options?: ConnectionMonitorsQueryOptionalParams): Promise<ConnectionMonitorsQueryResponse>;
    beginStart(resourceGroupName: string, networkWatcherName: string, connectionMonitorName: string, options?: ConnectionMonitorsStartOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    beginStartAndWait(resourceGroupName: string, networkWatcherName: string, connectionMonitorName: string, options?: ConnectionMonitorsStartOptionalParams): Promise<void>;
    beginStop(resourceGroupName: string, networkWatcherName: string, connectionMonitorName: string, options?: ConnectionMonitorsStopOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    beginStopAndWait(resourceGroupName: string, networkWatcherName: string, connectionMonitorName: string, options?: ConnectionMonitorsStopOptionalParams): Promise<void>;
    get(resourceGroupName: string, networkWatcherName: string, connectionMonitorName: string, options?: ConnectionMonitorsGetOptionalParams): Promise<ConnectionMonitorsGetResponse>;
    list(resourceGroupName: string, networkWatcherName: string, options?: ConnectionMonitorsListOptionalParams): PagedAsyncIterableIterator<ConnectionMonitorResult>;
    updateTags(resourceGroupName: string, networkWatcherName: string, connectionMonitorName: string, parameters: TagsObject, options?: ConnectionMonitorsUpdateTagsOptionalParams): Promise<ConnectionMonitorsUpdateTagsResponse>;
}

// @public
export interface ConnectionMonitorsCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    migrate?: string;
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type ConnectionMonitorsCreateOrUpdateResponse = ConnectionMonitorResult;

// @public
export interface ConnectionMonitorsDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface ConnectionMonitorsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ConnectionMonitorsGetResponse = ConnectionMonitorResult;

// @public
export interface ConnectionMonitorsListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ConnectionMonitorsListResponse = ConnectionMonitorListResult;

// @public
export interface ConnectionMonitorSource {
    port?: number;
    resourceId: string;
}

// @public
export type ConnectionMonitorSourceStatus = string;

// @public
export interface ConnectionMonitorsQueryOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type ConnectionMonitorsQueryResponse = ConnectionMonitorQueryResult;

// @public
export interface ConnectionMonitorsStartOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface ConnectionMonitorsStopOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface ConnectionMonitorSuccessThreshold {
    checksFailedPercent?: number;
    roundTripTimeMs?: number;
}

// @public
export interface ConnectionMonitorsUpdateTagsOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ConnectionMonitorsUpdateTagsResponse = ConnectionMonitorResult;

// @public
export interface ConnectionMonitorTcpConfiguration {
    destinationPortBehavior?: DestinationPortBehavior;
    disableTraceRoute?: boolean;
    port?: number;
}

// @public
export interface ConnectionMonitorTestConfiguration {
    httpConfiguration?: ConnectionMonitorHttpConfiguration;
    icmpConfiguration?: ConnectionMonitorIcmpConfiguration;
    name: string;
    preferredIPVersion?: PreferredIPVersion;
    protocol: ConnectionMonitorTestConfigurationProtocol;
    successThreshold?: ConnectionMonitorSuccessThreshold;
    tcpConfiguration?: ConnectionMonitorTcpConfiguration;
    testFrequencySec?: number;
}

// @public
export type ConnectionMonitorTestConfigurationProtocol = string;

// @public
export interface ConnectionMonitorTestGroup {
    destinations: string[];
    disable?: boolean;
    name: string;
    sources: string[];
    testConfigurations: string[];
}

// @public
export type ConnectionMonitorType = string;

// @public
export interface ConnectionMonitorWorkspaceSettings {
    workspaceResourceId?: string;
}

// @public
export type ConnectionState = string;

// @public
export interface ConnectionStateSnapshot {
    avgLatencyInMs?: number;
    connectionState?: ConnectionState;
    endTime?: Date;
    evaluationState?: EvaluationState;
    readonly hops?: ConnectivityHop[];
    maxLatencyInMs?: number;
    minLatencyInMs?: number;
    probesFailed?: number;
    probesSent?: number;
    startTime?: Date;
}

// @public
export type ConnectionStatus = string;

// @public
export interface ConnectivityDestination {
    address?: string;
    port?: number;
    resourceId?: string;
}

// @public
export interface ConnectivityHop {
    readonly address?: string;
    readonly id?: string;
    readonly issues?: ConnectivityIssue[];
    readonly links?: HopLink[];
    readonly nextHopIds?: string[];
    readonly previousHopIds?: string[];
    readonly previousLinks?: HopLink[];
    readonly resourceId?: string;
    readonly type?: string;
}

// @public
export interface ConnectivityInformation {
    readonly avgLatencyInMs?: number;
    readonly connectionStatus?: ConnectionStatus;
    readonly hops?: ConnectivityHop[];
    readonly maxLatencyInMs?: number;
    readonly minLatencyInMs?: number;
    readonly probesFailed?: number;
    readonly probesSent?: number;
}

// @public
export interface ConnectivityIssue {
    readonly context?: {
        [propertyName: string]: string;
    }[];
    readonly origin?: Origin;
    readonly severity?: Severity;
    readonly type?: IssueType;
}

// @public
export interface ConnectivityParameters {
    destination: ConnectivityDestination;
    preferredIPVersion?: IPVersion;
    protocol?: Protocol;
    protocolConfiguration?: ProtocolConfiguration;
    source: ConnectivitySource;
}

// @public
export interface ConnectivitySource {
    port?: number;
    resourceId: string;
}

// @public
export type CoverageLevel = string;

// @public
export type CreatedByType = string;

// @public
export type DestinationPortBehavior = string;

// @public
export type Direction = string;

// @public
export interface EffectiveNetworkSecurityRule {
    access?: SecurityRuleAccess;
    destinationAddressPrefix?: string;
    destinationAddressPrefixes?: string[];
    destinationPortRange?: string;
    destinationPortRanges?: string[];
    direction?: SecurityRuleDirection;
    expandedDestinationAddressPrefix?: string[];
    expandedSourceAddressPrefix?: string[];
    name?: string;
    priority?: number;
    protocol?: EffectiveSecurityRuleProtocol;
    sourceAddressPrefix?: string;
    sourceAddressPrefixes?: string[];
    sourcePortRange?: string;
    sourcePortRanges?: string[];
}

// @public
export type EffectiveSecurityRuleProtocol = string;

// @public
export type EndpointType = string;

// @public
export interface ErrorDetails {
    code?: string;
    message?: string;
    target?: string;
}

// @public
export interface ErrorModel {
    code?: string;
    details?: ErrorDetails[];
    innerError?: string;
    message?: string;
    target?: string;
}

// @public
export interface ErrorResponse {
    error?: ErrorDetails;
}

// @public
export interface EvaluatedNetworkSecurityGroup {
    appliedTo?: string;
    matchedRule?: MatchedRule;
    networkSecurityGroupId?: string;
    readonly rulesEvaluationResult?: NetworkSecurityRulesEvaluationResult[];
}

// @public
export type EvaluationState = string;

// @public
export interface ExtendedLocation {
    name?: string;
    type?: ExtendedLocationTypes;
}

// @public
export type ExtendedLocationTypes = string;

// @public
export interface FlowLog extends Resource {
    enabled?: boolean;
    readonly etag?: string;
    flowAnalyticsConfiguration?: TrafficAnalyticsProperties;
    format?: FlowLogFormatParameters;
    readonly provisioningState?: ProvisioningState;
    retentionPolicy?: RetentionPolicyParameters;
    storageId?: string;
    readonly targetResourceGuid?: string;
    targetResourceId?: string;
}

// @public
export interface FlowLogFormatParameters {
    type?: FlowLogFormatType;
    version?: number;
}

// @public
export type FlowLogFormatType = string;

// @public
export interface FlowLogInformation {
    enabled: boolean;
    flowAnalyticsConfiguration?: TrafficAnalyticsProperties;
    format?: FlowLogFormatParameters;
    retentionPolicy?: RetentionPolicyParameters;
    storageId: string;
    targetResourceId: string;
}

// @public
export interface FlowLogListResult {
    readonly nextLink?: string;
    value?: FlowLog[];
}

// @public
export interface FlowLogs {
    beginCreateOrUpdate(resourceGroupName: string, networkWatcherName: string, flowLogName: string, parameters: FlowLog, options?: FlowLogsCreateOrUpdateOptionalParams): Promise<SimplePollerLike<OperationState<FlowLogsCreateOrUpdateResponse>, FlowLogsCreateOrUpdateResponse>>;
    beginCreateOrUpdateAndWait(resourceGroupName: string, networkWatcherName: string, flowLogName: string, parameters: FlowLog, options?: FlowLogsCreateOrUpdateOptionalParams): Promise<FlowLogsCreateOrUpdateResponse>;
    beginDelete(resourceGroupName: string, networkWatcherName: string, flowLogName: string, options?: FlowLogsDeleteOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    beginDeleteAndWait(resourceGroupName: string, networkWatcherName: string, flowLogName: string, options?: FlowLogsDeleteOptionalParams): Promise<void>;
    get(resourceGroupName: string, networkWatcherName: string, flowLogName: string, options?: FlowLogsGetOptionalParams): Promise<FlowLogsGetResponse>;
    list(resourceGroupName: string, networkWatcherName: string, options?: FlowLogsListOptionalParams): PagedAsyncIterableIterator<FlowLog>;
    updateTags(resourceGroupName: string, networkWatcherName: string, flowLogName: string, parameters: TagsObject, options?: FlowLogsUpdateTagsOptionalParams): Promise<FlowLogsUpdateTagsResponse>;
}

// @public
export interface FlowLogsCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type FlowLogsCreateOrUpdateResponse = FlowLog;

// @public
export interface FlowLogsDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface FlowLogsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type FlowLogsGetResponse = FlowLog;

// @public
export interface FlowLogsListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type FlowLogsListNextResponse = FlowLogListResult;

// @public
export interface FlowLogsListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type FlowLogsListResponse = FlowLogListResult;

// @public
export interface FlowLogStatusParameters {
    targetResourceId: string;
}

// @public
export interface FlowLogsUpdateTagsOptionalParams extends coreClient.OperationOptions {
}

// @public
export type FlowLogsUpdateTagsResponse = FlowLog;

// @public
export function getContinuationToken(page: unknown): string | undefined;

// @public
export interface HopLink {
    readonly context?: {
        [propertyName: string]: string;
    };
    readonly issues?: ConnectivityIssue[];
    readonly linkType?: string;
    readonly nextHopId?: string;
    readonly resourceId?: string;
    readonly roundTripTimeAvg?: number;
    readonly roundTripTimeMax?: number;
    readonly roundTripTimeMin?: number;
}

// @public
export interface HttpConfiguration {
    headers?: HttpHeader[];
    method?: HttpMethod;
    validStatusCodes?: number[];
}

// @public
export type HttpConfigurationMethod = string;

// @public
export interface HttpHeader {
    name?: string;
    value?: string;
}

// @public
export type HttpMethod = string;

// @public
export type IPAllocationMethod = string;

// @public
export type IpFlowProtocol = string;

// @public
export type IPVersion = string;

// @public
export type IssueType = string;

// @public
export enum KnownAccess {
    Allow = "Allow",
    Deny = "Deny"
}

// @public
export enum KnownAssociationType {
    Associated = "Associated",
    Contains = "Contains"
}

// @public
export enum KnownAuthenticationMethod {
    EapmschaPv2 = "EAPMSCHAPv2",
    Eaptls = "EAPTLS"
}

// @public
export enum KnownConnectionMonitorEndpointFilterItemType {
    AgentAddress = "AgentAddress"
}

// @public
export enum KnownConnectionMonitorEndpointFilterType {
    Include = "Include"
}

// @public
export enum KnownConnectionMonitorSourceStatus {
    Active = "Active",
    Inactive = "Inactive",
    Unknown = "Unknown"
}

// @public
export enum KnownConnectionMonitorTestConfigurationProtocol {
    Http = "Http",
    Icmp = "Icmp",
    Tcp = "Tcp"
}

// @public
export enum KnownConnectionMonitorType {
    MultiEndpoint = "MultiEndpoint",
    SingleSourceDestination = "SingleSourceDestination"
}

// @public
export enum KnownConnectionState {
    Reachable = "Reachable",
    Unknown = "Unknown",
    Unreachable = "Unreachable"
}

// @public
export enum KnownConnectionStatus {
    Connected = "Connected",
    Degraded = "Degraded",
    Disconnected = "Disconnected",
    Unknown = "Unknown"
}

// @public
export enum KnownCoverageLevel {
    AboveAverage = "AboveAverage",
    Average = "Average",
    BelowAverage = "BelowAverage",
    Default = "Default",
    Full = "Full",
    Low = "Low"
}

// @public
export enum KnownCreatedByType {
    Application = "Application",
    Key = "Key",
    ManagedIdentity = "ManagedIdentity",
    User = "User"
}

// @public
export enum KnownDestinationPortBehavior {
    ListenIfAvailable = "ListenIfAvailable",
    None = "None"
}

// @public
export enum KnownDirection {
    Inbound = "Inbound",
    Outbound = "Outbound"
}

// @public
export enum KnownEffectiveSecurityRuleProtocol {
    All = "All",
    Tcp = "Tcp",
    Udp = "Udp"
}

// @public
export enum KnownEndpointType {
    AzureArcNetwork = "AzureArcNetwork",
    AzureArcVM = "AzureArcVM",
    AzureSubnet = "AzureSubnet",
    AzureVM = "AzureVM",
    AzureVmss = "AzureVMSS",
    AzureVNet = "AzureVNet",
    ExternalAddress = "ExternalAddress",
    MMAWorkspaceMachine = "MMAWorkspaceMachine",
    MMAWorkspaceNetwork = "MMAWorkspaceNetwork"
}

// @public
export enum KnownEvaluationState {
    Completed = "Completed",
    InProgress = "InProgress",
    NotStarted = "NotStarted"
}

// @public
export enum KnownExtendedLocationTypes {
    EdgeZone = "EdgeZone"
}

// @public
export enum KnownFlowLogFormatType {
    Json = "JSON"
}

// @public
export enum KnownHttpConfigurationMethod {
    Get = "Get",
    Post = "Post"
}

// @public
export enum KnownHttpMethod {
    Get = "Get"
}

// @public
export enum KnownIPAllocationMethod {
    Dynamic = "Dynamic",
    Static = "Static"
}

// @public
export enum KnownIpFlowProtocol {
    TCP = "TCP",
    UDP = "UDP"
}

// @public
export enum KnownIPVersion {
    IPv4 = "IPv4",
    IPv6 = "IPv6"
}

// @public
export enum KnownIssueType {
    AgentStopped = "AgentStopped",
    DnsResolution = "DnsResolution",
    GuestFirewall = "GuestFirewall",
    NetworkSecurityRule = "NetworkSecurityRule",
    Platform = "Platform",
    PortThrottled = "PortThrottled",
    SocketBind = "SocketBind",
    Unknown = "Unknown",
    UserDefinedRoute = "UserDefinedRoute"
}

// @public
export enum KnownNetworkOperationStatus {
    Failed = "Failed",
    InProgress = "InProgress",
    Succeeded = "Succeeded"
}

// @public
export enum KnownNextHopType {
    HyperNetGateway = "HyperNetGateway",
    Internet = "Internet",
    None = "None",
    VirtualAppliance = "VirtualAppliance",
    VirtualNetworkGateway = "VirtualNetworkGateway",
    VnetLocal = "VnetLocal"
}

// @public
export enum KnownOrigin {
    Inbound = "Inbound",
    Local = "Local",
    Outbound = "Outbound"
}

// @public
export enum KnownOutputType {
    Workspace = "Workspace"
}

// @public
export enum KnownPcError {
    AgentStopped = "AgentStopped",
    CaptureFailed = "CaptureFailed",
    InternalError = "InternalError",
    LocalFileFailed = "LocalFileFailed",
    StorageFailed = "StorageFailed"
}

// @public
export enum KnownPcProtocol {
    Any = "Any",
    TCP = "TCP",
    UDP = "UDP"
}

// @public
export enum KnownPcStatus {
    Error = "Error",
    NotStarted = "NotStarted",
    Running = "Running",
    Stopped = "Stopped",
    Unknown = "Unknown"
}

// @public
export enum KnownPreferredIPVersion {
    IPv4 = "IPv4",
    IPv6 = "IPv6"
}

// @public
export enum KnownProtocol {
    Http = "Http",
    Https = "Https",
    Icmp = "Icmp",
    Tcp = "Tcp"
}

// @public
export enum KnownProvisioningState {
    Deleting = "Deleting",
    Failed = "Failed",
    Succeeded = "Succeeded",
    Updating = "Updating"
}

// @public
export enum KnownSecurityRuleAccess {
    Allow = "Allow",
    Deny = "Deny"
}

// @public
export enum KnownSecurityRuleDirection {
    Inbound = "Inbound",
    Outbound = "Outbound"
}

// @public
export enum KnownSecurityRuleProtocol {
    Ah = "Ah",
    Asterisk = "*",
    Esp = "Esp",
    Icmp = "Icmp",
    Tcp = "Tcp",
    Udp = "Udp"
}

// @public
export enum KnownSeverity {
    Error = "Error",
    Warning = "Warning"
}

// @public
export enum KnownVerbosityLevel {
    Full = "Full",
    Minimum = "Minimum",
    Normal = "Normal"
}

// @public
export interface ManagedServiceIdentity {
    readonly principalId?: string;
    readonly tenantId?: string;
    type?: ResourceIdentityType;
    userAssignedIdentities?: {
        [propertyName: string]: Components1Jq1T4ISchemasManagedserviceidentityPropertiesUserassignedidentitiesAdditionalproperties;
    };
}

// @public
export interface MatchedRule {
    action?: string;
    ruleName?: string;
}

// @public
export interface NetworkConfigurationDiagnosticParameters {
    profiles: NetworkConfigurationDiagnosticProfile[];
    targetResourceId: string;
    verbosityLevel?: VerbosityLevel;
}

// @public
export interface NetworkConfigurationDiagnosticProfile {
    destination: string;
    destinationPort: string;
    direction: Direction;
    protocol: string;
    source: string;
}

// @public
export interface NetworkConfigurationDiagnosticResponse {
    readonly results?: NetworkConfigurationDiagnosticResult[];
}

// @public
export interface NetworkConfigurationDiagnosticResult {
    networkSecurityGroupResult?: NetworkSecurityGroupResult;
    profile?: NetworkConfigurationDiagnosticProfile;
}

// @public
export interface NetworkInterfaceAssociation {
    readonly id?: string;
    securityRules?: SecurityRule[];
}

// @public (undocumented)
export class NetworkManagementClient extends coreClient.ServiceClient {
    // (undocumented)
    $host: string;
    constructor(credentials: coreAuth.TokenCredential, subscriptionId: string, options?: NetworkManagementClientOptionalParams);
    // (undocumented)
    apiVersion: string;
    // (undocumented)
    connectionMonitors: ConnectionMonitors;
    // (undocumented)
    flowLogs: FlowLogs;
    // (undocumented)
    networkWatchers: NetworkWatchers;
    // (undocumented)
    packetCaptures: PacketCaptures;
    // (undocumented)
    subscriptionId: string;
}

// @public
export interface NetworkManagementClientOptionalParams extends coreClient.ServiceClientOptions {
    $host?: string;
    apiVersion?: string;
    endpoint?: string;
}

// @public
export type NetworkOperationStatus = string;

// @public
export interface NetworkSecurityGroupResult {
    readonly evaluatedNetworkSecurityGroups?: EvaluatedNetworkSecurityGroup[];
    securityRuleAccessResult?: SecurityRuleAccess;
}

// @public
export interface NetworkSecurityRulesEvaluationResult {
    destinationMatched?: boolean;
    destinationPortMatched?: boolean;
    name?: string;
    protocolMatched?: boolean;
    sourceMatched?: boolean;
    sourcePortMatched?: boolean;
}

// @public
export interface NetworkWatcher extends Resource {
    readonly etag?: string;
    readonly provisioningState?: ProvisioningState;
}

// @public
export interface NetworkWatcherListResult {
    value?: NetworkWatcher[];
}

// @public
export interface NetworkWatchers {
    beginCheckConnectivity(resourceGroupName: string, networkWatcherName: string, parameters: ConnectivityParameters, options?: NetworkWatchersCheckConnectivityOptionalParams): Promise<SimplePollerLike<OperationState<NetworkWatchersCheckConnectivityResponse>, NetworkWatchersCheckConnectivityResponse>>;
    beginCheckConnectivityAndWait(resourceGroupName: string, networkWatcherName: string, parameters: ConnectivityParameters, options?: NetworkWatchersCheckConnectivityOptionalParams): Promise<NetworkWatchersCheckConnectivityResponse>;
    beginDelete(resourceGroupName: string, networkWatcherName: string, options?: NetworkWatchersDeleteOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    beginDeleteAndWait(resourceGroupName: string, networkWatcherName: string, options?: NetworkWatchersDeleteOptionalParams): Promise<void>;
    beginGetAzureReachabilityReport(resourceGroupName: string, networkWatcherName: string, parameters: AzureReachabilityReportParameters, options?: NetworkWatchersGetAzureReachabilityReportOptionalParams): Promise<SimplePollerLike<OperationState<NetworkWatchersGetAzureReachabilityReportResponse>, NetworkWatchersGetAzureReachabilityReportResponse>>;
    beginGetAzureReachabilityReportAndWait(resourceGroupName: string, networkWatcherName: string, parameters: AzureReachabilityReportParameters, options?: NetworkWatchersGetAzureReachabilityReportOptionalParams): Promise<NetworkWatchersGetAzureReachabilityReportResponse>;
    beginGetFlowLogStatus(resourceGroupName: string, networkWatcherName: string, parameters: FlowLogStatusParameters, options?: NetworkWatchersGetFlowLogStatusOptionalParams): Promise<SimplePollerLike<OperationState<NetworkWatchersGetFlowLogStatusResponse>, NetworkWatchersGetFlowLogStatusResponse>>;
    beginGetFlowLogStatusAndWait(resourceGroupName: string, networkWatcherName: string, parameters: FlowLogStatusParameters, options?: NetworkWatchersGetFlowLogStatusOptionalParams): Promise<NetworkWatchersGetFlowLogStatusResponse>;
    beginGetNetworkConfigurationDiagnostic(resourceGroupName: string, networkWatcherName: string, parameters: NetworkConfigurationDiagnosticParameters, options?: NetworkWatchersGetNetworkConfigurationDiagnosticOptionalParams): Promise<SimplePollerLike<OperationState<NetworkWatchersGetNetworkConfigurationDiagnosticResponse>, NetworkWatchersGetNetworkConfigurationDiagnosticResponse>>;
    beginGetNetworkConfigurationDiagnosticAndWait(resourceGroupName: string, networkWatcherName: string, parameters: NetworkConfigurationDiagnosticParameters, options?: NetworkWatchersGetNetworkConfigurationDiagnosticOptionalParams): Promise<NetworkWatchersGetNetworkConfigurationDiagnosticResponse>;
    beginGetNextHop(resourceGroupName: string, networkWatcherName: string, parameters: NextHopParameters, options?: NetworkWatchersGetNextHopOptionalParams): Promise<SimplePollerLike<OperationState<NetworkWatchersGetNextHopResponse>, NetworkWatchersGetNextHopResponse>>;
    beginGetNextHopAndWait(resourceGroupName: string, networkWatcherName: string, parameters: NextHopParameters, options?: NetworkWatchersGetNextHopOptionalParams): Promise<NetworkWatchersGetNextHopResponse>;
    beginGetTroubleshooting(resourceGroupName: string, networkWatcherName: string, parameters: TroubleshootingParameters, options?: NetworkWatchersGetTroubleshootingOptionalParams): Promise<SimplePollerLike<OperationState<NetworkWatchersGetTroubleshootingResponse>, NetworkWatchersGetTroubleshootingResponse>>;
    beginGetTroubleshootingAndWait(resourceGroupName: string, networkWatcherName: string, parameters: TroubleshootingParameters, options?: NetworkWatchersGetTroubleshootingOptionalParams): Promise<NetworkWatchersGetTroubleshootingResponse>;
    beginGetTroubleshootingResult(resourceGroupName: string, networkWatcherName: string, parameters: QueryTroubleshootingParameters, options?: NetworkWatchersGetTroubleshootingResultOptionalParams): Promise<SimplePollerLike<OperationState<NetworkWatchersGetTroubleshootingResultResponse>, NetworkWatchersGetTroubleshootingResultResponse>>;
    beginGetTroubleshootingResultAndWait(resourceGroupName: string, networkWatcherName: string, parameters: QueryTroubleshootingParameters, options?: NetworkWatchersGetTroubleshootingResultOptionalParams): Promise<NetworkWatchersGetTroubleshootingResultResponse>;
    beginGetVMSecurityRules(resourceGroupName: string, networkWatcherName: string, parameters: SecurityGroupViewParameters, options?: NetworkWatchersGetVMSecurityRulesOptionalParams): Promise<SimplePollerLike<OperationState<NetworkWatchersGetVMSecurityRulesResponse>, NetworkWatchersGetVMSecurityRulesResponse>>;
    beginGetVMSecurityRulesAndWait(resourceGroupName: string, networkWatcherName: string, parameters: SecurityGroupViewParameters, options?: NetworkWatchersGetVMSecurityRulesOptionalParams): Promise<NetworkWatchersGetVMSecurityRulesResponse>;
    beginListAvailableProviders(resourceGroupName: string, networkWatcherName: string, parameters: AvailableProvidersListParameters, options?: NetworkWatchersListAvailableProvidersOptionalParams): Promise<SimplePollerLike<OperationState<NetworkWatchersListAvailableProvidersResponse>, NetworkWatchersListAvailableProvidersResponse>>;
    beginListAvailableProvidersAndWait(resourceGroupName: string, networkWatcherName: string, parameters: AvailableProvidersListParameters, options?: NetworkWatchersListAvailableProvidersOptionalParams): Promise<NetworkWatchersListAvailableProvidersResponse>;
    beginSetFlowLogConfiguration(resourceGroupName: string, networkWatcherName: string, parameters: FlowLogInformation, options?: NetworkWatchersSetFlowLogConfigurationOptionalParams): Promise<SimplePollerLike<OperationState<NetworkWatchersSetFlowLogConfigurationResponse>, NetworkWatchersSetFlowLogConfigurationResponse>>;
    beginSetFlowLogConfigurationAndWait(resourceGroupName: string, networkWatcherName: string, parameters: FlowLogInformation, options?: NetworkWatchersSetFlowLogConfigurationOptionalParams): Promise<NetworkWatchersSetFlowLogConfigurationResponse>;
    beginVerifyIPFlow(resourceGroupName: string, networkWatcherName: string, parameters: VerificationIPFlowParameters, options?: NetworkWatchersVerifyIPFlowOptionalParams): Promise<SimplePollerLike<OperationState<NetworkWatchersVerifyIPFlowResponse>, NetworkWatchersVerifyIPFlowResponse>>;
    beginVerifyIPFlowAndWait(resourceGroupName: string, networkWatcherName: string, parameters: VerificationIPFlowParameters, options?: NetworkWatchersVerifyIPFlowOptionalParams): Promise<NetworkWatchersVerifyIPFlowResponse>;
    createOrUpdate(resourceGroupName: string, networkWatcherName: string, parameters: NetworkWatcher, options?: NetworkWatchersCreateOrUpdateOptionalParams): Promise<NetworkWatchersCreateOrUpdateResponse>;
    get(resourceGroupName: string, networkWatcherName: string, options?: NetworkWatchersGetOptionalParams): Promise<NetworkWatchersGetResponse>;
    getTopology(resourceGroupName: string, networkWatcherName: string, parameters: TopologyParameters, options?: NetworkWatchersGetTopologyOptionalParams): Promise<NetworkWatchersGetTopologyResponse>;
    list(resourceGroupName: string, options?: NetworkWatchersListOptionalParams): PagedAsyncIterableIterator<NetworkWatcher>;
    listAll(options?: NetworkWatchersListAllOptionalParams): PagedAsyncIterableIterator<NetworkWatcher>;
    updateTags(resourceGroupName: string, networkWatcherName: string, parameters: TagsObject, options?: NetworkWatchersUpdateTagsOptionalParams): Promise<NetworkWatchersUpdateTagsResponse>;
}

// @public
export interface NetworkWatchersCheckConnectivityOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type NetworkWatchersCheckConnectivityResponse = ConnectivityInformation;

// @public
export interface NetworkWatchersCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
}

// @public
export type NetworkWatchersCreateOrUpdateResponse = NetworkWatcher;

// @public
export interface NetworkWatchersDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface NetworkWatchersGetAzureReachabilityReportOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type NetworkWatchersGetAzureReachabilityReportResponse = AzureReachabilityReport;

// @public
export interface NetworkWatchersGetFlowLogStatusOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type NetworkWatchersGetFlowLogStatusResponse = FlowLogInformation;

// @public
export interface NetworkWatchersGetNetworkConfigurationDiagnosticOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type NetworkWatchersGetNetworkConfigurationDiagnosticResponse = NetworkConfigurationDiagnosticResponse;

// @public
export interface NetworkWatchersGetNextHopOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type NetworkWatchersGetNextHopResponse = NextHopResult;

// @public
export interface NetworkWatchersGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type NetworkWatchersGetResponse = NetworkWatcher;

// @public
export interface NetworkWatchersGetTopologyOptionalParams extends coreClient.OperationOptions {
}

// @public
export type NetworkWatchersGetTopologyResponse = Topology;

// @public
export interface NetworkWatchersGetTroubleshootingOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type NetworkWatchersGetTroubleshootingResponse = TroubleshootingResult;

// @public
export interface NetworkWatchersGetTroubleshootingResultOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type NetworkWatchersGetTroubleshootingResultResponse = TroubleshootingResult;

// @public
export interface NetworkWatchersGetVMSecurityRulesOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type NetworkWatchersGetVMSecurityRulesResponse = SecurityGroupViewResult;

// @public
export interface NetworkWatchersListAllOptionalParams extends coreClient.OperationOptions {
}

// @public
export type NetworkWatchersListAllResponse = NetworkWatcherListResult;

// @public
export interface NetworkWatchersListAvailableProvidersOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type NetworkWatchersListAvailableProvidersResponse = AvailableProvidersList;

// @public
export interface NetworkWatchersListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type NetworkWatchersListResponse = NetworkWatcherListResult;

// @public
export interface NetworkWatchersSetFlowLogConfigurationOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type NetworkWatchersSetFlowLogConfigurationResponse = FlowLogInformation;

// @public
export interface NetworkWatchersUpdateTagsOptionalParams extends coreClient.OperationOptions {
}

// @public
export type NetworkWatchersUpdateTagsResponse = NetworkWatcher;

// @public
export interface NetworkWatchersVerifyIPFlowOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type NetworkWatchersVerifyIPFlowResponse = VerificationIPFlowResult;

// @public
export interface NextHopParameters {
    destinationIPAddress: string;
    sourceIPAddress: string;
    targetNicResourceId?: string;
    targetResourceId: string;
}

// @public
export interface NextHopResult {
    nextHopIpAddress?: string;
    nextHopType?: NextHopType;
    routeTableId?: string;
}

// @public
export type NextHopType = string;

// @public
export type Origin = string;

// @public
export type OutputType = string;

// @public
export interface PacketCapture {
    bytesToCapturePerPacket?: number;
    filters?: PacketCaptureFilter[];
    scope?: PacketCaptureMachineScope;
    storageLocation: PacketCaptureStorageLocation;
    target: string;
    targetType?: PacketCaptureTargetType;
    timeLimitInSeconds?: number;
    totalBytesPerSession?: number;
}

// @public
export interface PacketCaptureFilter {
    localIPAddress?: string;
    localPort?: string;
    protocol?: PcProtocol;
    remoteIPAddress?: string;
    remotePort?: string;
}

// @public
export interface PacketCaptureListResult {
    value?: PacketCaptureResult[];
}

// @public
export interface PacketCaptureMachineScope {
    exclude?: string[];
    include?: string[];
}

// @public
export interface PacketCaptureParameters {
    bytesToCapturePerPacket?: number;
    filters?: PacketCaptureFilter[];
    scope?: PacketCaptureMachineScope;
    storageLocation: PacketCaptureStorageLocation;
    target: string;
    targetType?: PacketCaptureTargetType;
    timeLimitInSeconds?: number;
    totalBytesPerSession?: number;
}

// @public
export interface PacketCaptureQueryStatusResult {
    captureStartTime?: Date;
    id?: string;
    name?: string;
    packetCaptureError?: PcError[];
    packetCaptureStatus?: PcStatus;
    stopReason?: string;
}

// @public
export interface PacketCaptureResult {
    bytesToCapturePerPacket?: number;
    readonly etag?: string;
    filters?: PacketCaptureFilter[];
    readonly id?: string;
    readonly name?: string;
    readonly provisioningState?: ProvisioningState;
    scope?: PacketCaptureMachineScope;
    storageLocation?: PacketCaptureStorageLocation;
    target?: string;
    targetType?: PacketCaptureTargetType;
    timeLimitInSeconds?: number;
    totalBytesPerSession?: number;
}

// @public
export interface PacketCaptureResultProperties extends PacketCaptureParameters {
    readonly provisioningState?: ProvisioningState;
}

// @public
export interface PacketCaptures {
    beginCreate(resourceGroupName: string, networkWatcherName: string, packetCaptureName: string, parameters: PacketCapture, options?: PacketCapturesCreateOptionalParams): Promise<SimplePollerLike<OperationState<PacketCapturesCreateResponse>, PacketCapturesCreateResponse>>;
    beginCreateAndWait(resourceGroupName: string, networkWatcherName: string, packetCaptureName: string, parameters: PacketCapture, options?: PacketCapturesCreateOptionalParams): Promise<PacketCapturesCreateResponse>;
    beginDelete(resourceGroupName: string, networkWatcherName: string, packetCaptureName: string, options?: PacketCapturesDeleteOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    beginDeleteAndWait(resourceGroupName: string, networkWatcherName: string, packetCaptureName: string, options?: PacketCapturesDeleteOptionalParams): Promise<void>;
    beginGetStatus(resourceGroupName: string, networkWatcherName: string, packetCaptureName: string, options?: PacketCapturesGetStatusOptionalParams): Promise<SimplePollerLike<OperationState<PacketCapturesGetStatusResponse>, PacketCapturesGetStatusResponse>>;
    beginGetStatusAndWait(resourceGroupName: string, networkWatcherName: string, packetCaptureName: string, options?: PacketCapturesGetStatusOptionalParams): Promise<PacketCapturesGetStatusResponse>;
    beginStop(resourceGroupName: string, networkWatcherName: string, packetCaptureName: string, options?: PacketCapturesStopOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    beginStopAndWait(resourceGroupName: string, networkWatcherName: string, packetCaptureName: string, options?: PacketCapturesStopOptionalParams): Promise<void>;
    get(resourceGroupName: string, networkWatcherName: string, packetCaptureName: string, options?: PacketCapturesGetOptionalParams): Promise<PacketCapturesGetResponse>;
    list(resourceGroupName: string, networkWatcherName: string, options?: PacketCapturesListOptionalParams): PagedAsyncIterableIterator<PacketCaptureResult>;
}

// @public
export interface PacketCapturesCreateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type PacketCapturesCreateResponse = PacketCaptureResult;

// @public
export interface PacketCapturesDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface PacketCapturesGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type PacketCapturesGetResponse = PacketCaptureResult;

// @public
export interface PacketCapturesGetStatusOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type PacketCapturesGetStatusResponse = PacketCaptureQueryStatusResult;

// @public
export interface PacketCapturesListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type PacketCapturesListResponse = PacketCaptureListResult;

// @public
export interface PacketCapturesStopOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface PacketCaptureStorageLocation {
    filePath?: string;
    storageId?: string;
    storagePath?: string;
}

// @public
export type PacketCaptureTargetType = "AzureVM" | "AzureVMSS";

// @public
export type PcError = string;

// @public
export type PcProtocol = string;

// @public
export type PcStatus = string;

// @public
export type PreferredIPVersion = string;

// @public
export type Protocol = string;

// @public
export interface ProtocolConfiguration {
    httpConfiguration?: HttpConfiguration;
}

// @public
export type ProvisioningState = string;

// @public
export interface ProxyResource {
    readonly etag?: string;
    readonly id?: string;
    readonly name?: string;
    readonly type?: string;
}

// @public
export interface QueryTroubleshootingParameters {
    targetResourceId: string;
}

// @public
export interface Resource {
    id?: string;
    location?: string;
    readonly name?: string;
    tags?: {
        [propertyName: string]: string;
    };
    readonly type?: string;
}

// @public
export type ResourceIdentityType = "SystemAssigned" | "UserAssigned" | "SystemAssigned, UserAssigned" | "None";

// @public
export interface RetentionPolicyParameters {
    days?: number;
    enabled?: boolean;
}

// @public
export interface SecurityGroupNetworkInterface {
    id?: string;
    securityRuleAssociations?: SecurityRuleAssociations;
}

// @public
export interface SecurityGroupViewParameters {
    targetResourceId: string;
}

// @public
export interface SecurityGroupViewResult {
    networkInterfaces?: SecurityGroupNetworkInterface[];
}

// @public
export interface SecurityRule extends SubResource {
    access?: SecurityRuleAccess;
    description?: string;
    destinationAddressPrefix?: string;
    destinationAddressPrefixes?: string[];
    destinationApplicationSecurityGroups?: ApplicationSecurityGroup[];
    destinationPortRange?: string;
    destinationPortRanges?: string[];
    direction?: SecurityRuleDirection;
    readonly etag?: string;
    name?: string;
    priority?: number;
    protocol?: SecurityRuleProtocol;
    readonly provisioningState?: ProvisioningState;
    sourceAddressPrefix?: string;
    sourceAddressPrefixes?: string[];
    sourceApplicationSecurityGroups?: ApplicationSecurityGroup[];
    sourcePortRange?: string;
    sourcePortRanges?: string[];
    type?: string;
}

// @public
export type SecurityRuleAccess = string;

// @public
export interface SecurityRuleAssociations {
    defaultSecurityRules?: SecurityRule[];
    effectiveSecurityRules?: EffectiveNetworkSecurityRule[];
    networkInterfaceAssociation?: NetworkInterfaceAssociation;
    subnetAssociation?: SubnetAssociation;
}

// @public
export type SecurityRuleDirection = string;

// @public
export interface SecurityRuleListResult {
    nextLink?: string;
    value?: SecurityRule[];
}

// @public
export type SecurityRuleProtocol = string;

// @public
export type Severity = string;

// @public
export interface SubnetAssociation {
    readonly id?: string;
    securityRules?: SecurityRule[];
}

// @public
export interface SubResource {
    id?: string;
}

// @public
export interface SystemData {
    createdAt?: Date;
    createdBy?: string;
    createdByType?: CreatedByType;
    lastModifiedAt?: Date;
    lastModifiedBy?: string;
    lastModifiedByType?: CreatedByType;
}

// @public
export interface TagsObject {
    tags?: {
        [propertyName: string]: string;
    };
}

// @public
export interface Topology {
    readonly createdDateTime?: Date;
    readonly id?: string;
    readonly lastModified?: Date;
    resources?: TopologyResource[];
}

// @public
export interface TopologyAssociation {
    associationType?: AssociationType;
    name?: string;
    resourceId?: string;
}

// @public
export interface TopologyParameters {
    targetResourceGroupName?: string;
    targetSubnet?: SubResource;
    targetVirtualNetwork?: SubResource;
}

// @public
export interface TopologyResource {
    associations?: TopologyAssociation[];
    id?: string;
    location?: string;
    name?: string;
}

// @public
export interface TrafficAnalyticsConfigurationProperties {
    enabled?: boolean;
    trafficAnalyticsInterval?: number;
    workspaceId?: string;
    workspaceRegion?: string;
    workspaceResourceId?: string;
}

// @public
export interface TrafficAnalyticsProperties {
    networkWatcherFlowAnalyticsConfiguration?: TrafficAnalyticsConfigurationProperties;
}

// @public
export interface TroubleshootingDetails {
    detail?: string;
    id?: string;
    reasonType?: string;
    recommendedActions?: TroubleshootingRecommendedActions[];
    summary?: string;
}

// @public
export interface TroubleshootingParameters {
    storageId: string;
    storagePath: string;
    targetResourceId: string;
}

// @public
export interface TroubleshootingRecommendedActions {
    actionId?: string;
    actionText?: string;
    actionUri?: string;
    actionUriText?: string;
}

// @public
export interface TroubleshootingResult {
    code?: string;
    endTime?: Date;
    results?: TroubleshootingDetails[];
    startTime?: Date;
}

// @public
export type VerbosityLevel = string;

// @public
export interface VerificationIPFlowParameters {
    direction: Direction;
    localIPAddress: string;
    localPort: string;
    protocol: IpFlowProtocol;
    remoteIPAddress: string;
    remotePort: string;
    targetNicResourceId?: string;
    targetResourceId: string;
}

// @public
export interface VerificationIPFlowResult {
    access?: Access;
    ruleName?: string;
}

// (No @packageDocumentation comment for this package)

```
