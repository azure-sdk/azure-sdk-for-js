## API Report File for "@azure/arm-messagingconnectors"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import * as coreAuth from '@azure/core-auth';
import * as coreClient from '@azure/core-client';
import { PagedAsyncIterableIterator } from '@azure/core-paging';

// @public
export type ActionType = string;

// @public
export interface BitCoinSourceConnectorProperties extends ConnectorProperties {
    connectorType: "BitCoinSource";
}

// @public
export interface ConfluentSourceConnectorProperties extends ConnectorProperties {
    autoOffsetReset: string;
    bootstrapServers: string;
    connectorType: "ConfluentSource";
    consumerGroup: string;
    password: string;
    topic: string;
    user: string;
}

// @public
export interface ConnectorInstance extends TrackedResource {
    readonly connectorDirection?: Direction;
    readonly connectorState?: ConnectorState;
    readonly connectorType?: ConnectorType;
    eventHubConfig?: EventHubConfig;
    maxTasks?: number;
    readonly provisioningState?: ConnectorProvisioningState;
    valueConverter?: ConverterType;
}

// @public
export interface ConnectorInstanceListResult {
    nextLink?: string;
    value: ConnectorInstance[];
}

// @public
export interface ConnectorInstanceTagsUpdate {
    tags?: {
        [propertyName: string]: string;
    };
}

// @public
export interface ConnectorOperations {
    createOrUpdate(resourceGroupName: string, name: string, resource: ConnectorInstance, options?: ConnectorOperationsCreateOrUpdateOptionalParams): Promise<ConnectorOperationsCreateOrUpdateResponse>;
    delete(resourceGroupName: string, name: string, options?: ConnectorOperationsDeleteOptionalParams): Promise<void>;
    get(resourceGroupName: string, name: string, options?: ConnectorOperationsGetOptionalParams): Promise<ConnectorOperationsGetResponse>;
    listByResourceGroup(resourceGroupName: string, options?: ConnectorOperationsListByResourceGroupOptionalParams): PagedAsyncIterableIterator<ConnectorInstance>;
    listBySubscription(options?: ConnectorOperationsListBySubscriptionOptionalParams): PagedAsyncIterableIterator<ConnectorInstance>;
    pause(resourceGroupName: string, name: string, body: Record<string, unknown>, options?: ConnectorOperationsPauseOptionalParams): Promise<void>;
    resume(resourceGroupName: string, name: string, body: Record<string, unknown>, options?: ConnectorOperationsResumeOptionalParams): Promise<void>;
    updateTags(resourceGroupName: string, name: string, properties: ConnectorInstanceTagsUpdate, options?: ConnectorOperationsUpdateTagsOptionalParams): Promise<ConnectorOperationsUpdateTagsResponse>;
}

// @public
export interface ConnectorOperationsCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ConnectorOperationsCreateOrUpdateResponse = ConnectorInstance;

// @public
export interface ConnectorOperationsDeleteOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface ConnectorOperationsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ConnectorOperationsGetResponse = ConnectorInstance;

// @public
export interface ConnectorOperationsListByResourceGroupNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ConnectorOperationsListByResourceGroupNextResponse = ConnectorInstanceListResult;

// @public
export interface ConnectorOperationsListByResourceGroupOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ConnectorOperationsListByResourceGroupResponse = ConnectorInstanceListResult;

// @public
export interface ConnectorOperationsListBySubscriptionNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ConnectorOperationsListBySubscriptionNextResponse = ConnectorInstanceListResult;

// @public
export interface ConnectorOperationsListBySubscriptionOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ConnectorOperationsListBySubscriptionResponse = ConnectorInstanceListResult;

// @public
export interface ConnectorOperationsPauseOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface ConnectorOperationsResumeOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface ConnectorOperationsUpdateTagsOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ConnectorOperationsUpdateTagsResponse = ConnectorInstance;

// @public
export interface ConnectorProperties {
    readonly connectorDirection?: Direction;
    readonly connectorState: ConnectorState;
    connectorType: "BitCoinSource" | "ConfluentSource" | "CosmosDbSource" | "GooglePubSubSource" | "KinesisSource" | "PostgreSqlSource" | "SqlServerSource";
    eventHubConfig: EventHubConfig;
    maxTasks: number;
    readonly provisioningState?: ConnectorProvisioningState;
    valueConverter: ConverterType;
}

// @public (undocumented)
export type ConnectorPropertiesUnion = ConnectorProperties | BitCoinSourceConnectorProperties | ConfluentSourceConnectorProperties | CosmosDbSourceConnectorProperties | GooglePubSubSourceConnectorProperties | KinesisSourceConnectorProperties | PostgreSqlSourceConnectorProperties | SqlServerSourceConnectorProperties;

// @public
export type ConnectorProvisioningState = string;

// @public
export type ConnectorState = string;

// @public
export type ConnectorType = string;

// @public
export type ConverterType = string;

// @public
export interface CosmosDbSourceConnectorProperties extends ConnectorProperties {
    connectorType: "CosmosDbSource";
    container: string;
    cosmosEndpoint: string;
    databaseName: string;
    masterKey: string;
    offsetPolicy: OffsetPolicyForCosmosDB;
    pollIntervalInMs: number;
}

// @public
export type CreatedByType = string;

// @public
export type Direction = string;

// @public
export interface ErrorAdditionalInfo {
    readonly info?: Record<string, unknown>;
    readonly type?: string;
}

// @public
export interface ErrorDetail {
    readonly additionalInfo?: ErrorAdditionalInfo[];
    readonly code?: string;
    readonly details?: ErrorDetail[];
    readonly message?: string;
    readonly target?: string;
}

// @public
export interface ErrorResponse {
    error?: ErrorDetail;
}

// @public
export interface EventHubConfig {
    connectionString: string;
    eventHubName: string;
    namespaceHostName: string;
}

// @public
export function getContinuationToken(page: unknown): string | undefined;

// @public
export interface GooglePubSubSourceConnectorProperties extends ConnectorProperties {
    accountKey: string;
    connectorType: "GooglePubSubSource";
    projectId: string;
    subscriptionName: string;
}

// @public
export interface KinesisSourceConnectorProperties extends ConnectorProperties {
    awsAccessKeyId: string;
    awsKinesisRegion: string;
    awsKinesisStreamName: string;
    awsSecretAccessKey: string;
    connectorType: "KinesisSource";
}

// @public
export enum KnownActionType {
    Internal = "Internal"
}

// @public
export enum KnownConnectorProvisioningState {
    Accepted = "Accepted",
    Canceled = "Canceled",
    Creating = "Creating",
    Failed = "Failed",
    Succeeded = "Succeeded",
    Updating = "Updating"
}

// @public
export enum KnownConnectorState {
    Creating = "Creating",
    Degraded = "Degraded",
    Deleting = "Deleting",
    Failed = "Failed",
    Initializing = "Initializing",
    Paused = "Paused",
    Running = "Running",
    Stopped = "Stopped",
    Unknown = "Unknown",
    Updating = "Updating"
}

// @public
export enum KnownConnectorType {
    BitCoinSource = "BitCoinSource",
    ConfluentSource = "ConfluentSource",
    CosmosDbSource = "CosmosDbSource",
    GooglePubSubSource = "GooglePubSubSource",
    KafkaSource = "KafkaSource",
    KinesisSource = "KinesisSource",
    PostgreSqlSource = "PostgreSqlSource",
    SqlServerSource = "SqlServerSource",
    Unknown = "Unknown"
}

// @public
export enum KnownConverterType {
    AvroConverter = "AvroConverter",
    ByteArrayConverter = "ByteArrayConverter",
    CsvConverter = "CsvConverter",
    JsonConverter = "JsonConverter",
    StringConverter = "StringConverter",
    Unknown = "Unknown"
}

// @public
export enum KnownCreatedByType {
    Application = "Application",
    Key = "Key",
    ManagedIdentity = "ManagedIdentity",
    User = "User"
}

// @public
export enum KnownDirection {
    Sink = "Sink",
    Source = "Source",
    Unknown = "Unknown"
}

// @public
export enum KnownOffsetPolicyForCosmosDB {
    UseEarliestRecordedOffset = "UseEarliestRecordedOffset",
    UseLatestSourceOffset = "UseLatestSourceOffset"
}

// @public
export enum KnownOrigin {
    System = "system",
    User = "user",
    UserSystem = "user,system"
}

// @public
export enum KnownVersions {
    V20240120Preview = "2024-01-20-preview"
}

// @public (undocumented)
export class MicrosoftMessagingConnectorsManagementService extends coreClient.ServiceClient {
    // (undocumented)
    $host: string;
    constructor(credentials: coreAuth.TokenCredential, subscriptionId: string, options?: MicrosoftMessagingConnectorsManagementServiceOptionalParams);
    // (undocumented)
    apiVersion: string;
    // (undocumented)
    connectorOperations: ConnectorOperations;
    // (undocumented)
    operations: Operations;
    // (undocumented)
    subscriptionId: string;
}

// @public
export interface MicrosoftMessagingConnectorsManagementServiceOptionalParams extends coreClient.ServiceClientOptions {
    $host?: string;
    apiVersion?: string;
    endpoint?: string;
}

// @public
export type OffsetPolicyForCosmosDB = string;

// @public
export interface Operation {
    readonly actionType?: ActionType;
    display?: OperationDisplay;
    readonly isDataAction?: boolean;
    readonly name?: string;
    readonly origin?: Origin;
}

// @public
export interface OperationDisplay {
    readonly description?: string;
    readonly operation?: string;
    readonly provider?: string;
    readonly resource?: string;
}

// @public
export interface OperationListResult {
    readonly nextLink?: string;
    readonly value?: Operation[];
}

// @public
export interface Operations {
    list(options?: OperationsListOptionalParams): PagedAsyncIterableIterator<Operation>;
}

// @public
export interface OperationsListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type OperationsListNextResponse = OperationListResult;

// @public
export interface OperationsListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type OperationsListResponse = OperationListResult;

// @public
export type Origin = string;

// @public
export interface PostgreSqlSourceConnectorProperties extends ConnectorProperties {
    connectorType: "PostgreSqlSource";
    databaseName: string;
    hostName: string;
    password: string;
    port: number;
    replicationSlotName: string;
    username: string;
}

// @public
export interface Resource {
    readonly id?: string;
    readonly name?: string;
    readonly systemData?: SystemData;
    readonly type?: string;
}

// @public
export interface SqlServerSourceConnectorProperties extends ConnectorProperties {
    connectorType: "SqlServerSource";
    databaseName: string;
    hostName: string;
    password: string;
    port: number;
    username: string;
}

// @public
export interface SystemData {
    createdAt?: Date;
    createdBy?: string;
    createdByType?: CreatedByType;
    lastModifiedAt?: Date;
    lastModifiedBy?: string;
    lastModifiedByType?: CreatedByType;
}

// @public
export interface TrackedResource extends Resource {
    location: string;
    tags?: {
        [propertyName: string]: string;
    };
}

// @public
export type Versions = string;

// (No @packageDocumentation comment for this package)

```
