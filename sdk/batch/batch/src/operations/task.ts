/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import { PagedAsyncIterableIterator } from "@azure/core-paging";
import { Task } from "../operationsInterfaces";
import * as coreClient from "@azure/core-client";
import * as Mappers from "../models/mappers";
import * as Parameters from "../models/parameters";
import { BatchServiceClient } from "../batchServiceClient";
import {
  CloudTask,
  TaskListNextOptionalParams,
  TaskListOptionalParams,
  TaskAddParameter,
  TaskAddOptionalParams,
  TaskAddResponse,
  TaskListResponse,
  TaskAddCollectionParameter,
  TaskAddCollectionOptionalParams,
  TaskAddCollectionResponse,
  TaskDeleteOptionalParams,
  TaskDeleteResponse,
  TaskGetOptionalParams,
  TaskGetResponse,
  TaskUpdateParameter,
  TaskUpdateOptionalParams,
  TaskUpdateResponse,
  TaskListSubtasksOptionalParams,
  TaskListSubtasksResponse,
  TaskTerminateOptionalParams,
  TaskTerminateResponse,
  TaskReactivateOptionalParams,
  TaskReactivateResponse,
  TaskListNextResponse
} from "../models";

/// <reference lib="esnext.asynciterable" />
/** Class containing Task operations. */
export class TaskImpl implements Task {
  private readonly client: BatchServiceClient;

  /**
   * Initialize a new instance of the class Task class.
   * @param client Reference to the service client
   */
  constructor(client: BatchServiceClient) {
    this.client = client;
  }

  /**
   * For multi-instance Tasks, information such as affinityId, executionInfo and nodeInfo refer to the
   * primary Task. Use the list subtasks API to retrieve information about subtasks.
   * @param jobId The ID of the Job.
   * @param options The options parameters.
   */
  public list(
    jobId: string,
    options?: TaskListOptionalParams
  ): PagedAsyncIterableIterator<CloudTask> {
    const iter = this.listPagingAll(jobId, options);
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.listPagingPage(jobId, options);
      }
    };
  }

  private async *listPagingPage(
    jobId: string,
    options?: TaskListOptionalParams
  ): AsyncIterableIterator<CloudTask[]> {
    let result = await this._list(jobId, options);
    yield result.value || [];
    let continuationToken = result.odataNextLink;
    while (continuationToken) {
      result = await this._listNext(jobId, continuationToken, options);
      continuationToken = result.odataNextLink;
      yield result.value || [];
    }
  }

  private async *listPagingAll(
    jobId: string,
    options?: TaskListOptionalParams
  ): AsyncIterableIterator<CloudTask> {
    for await (const page of this.listPagingPage(jobId, options)) {
      yield* page;
    }
  }

  /**
   * The maximum lifetime of a Task from addition to completion is 180 days. If a Task has not completed
   * within 180 days of being added it will be terminated by the Batch service and left in whatever state
   * it was in at that time.
   * @param jobId The ID of the Job to which the Task is to be added.
   * @param task The Task to be added.
   * @param options The options parameters.
   */
  add(
    jobId: string,
    task: TaskAddParameter,
    options?: TaskAddOptionalParams
  ): Promise<TaskAddResponse> {
    return this.client.sendOperationRequest(
      { jobId, task, options },
      addOperationSpec
    );
  }

  /**
   * For multi-instance Tasks, information such as affinityId, executionInfo and nodeInfo refer to the
   * primary Task. Use the list subtasks API to retrieve information about subtasks.
   * @param jobId The ID of the Job.
   * @param options The options parameters.
   */
  private _list(
    jobId: string,
    options?: TaskListOptionalParams
  ): Promise<TaskListResponse> {
    return this.client.sendOperationRequest(
      { jobId, options },
      listOperationSpec
    );
  }

  /**
   * Note that each Task must have a unique ID. The Batch service may not return the results for each
   * Task in the same order the Tasks were submitted in this request. If the server times out or the
   * connection is closed during the request, the request may have been partially or fully processed, or
   * not at all. In such cases, the user should re-issue the request. Note that it is up to the user to
   * correctly handle failures when re-issuing a request. For example, you should use the same Task IDs
   * during a retry so that if the prior operation succeeded, the retry will not create extra Tasks
   * unexpectedly. If the response contains any Tasks which failed to add, a client can retry the
   * request. In a retry, it is most efficient to resubmit only Tasks that failed to add, and to omit
   * Tasks that were successfully added on the first attempt. The maximum lifetime of a Task from
   * addition to completion is 180 days. If a Task has not completed within 180 days of being added it
   * will be terminated by the Batch service and left in whatever state it was in at that time.
   * @param jobId The ID of the Job to which the Task collection is to be added.
   * @param taskCollection The Tasks to be added.
   * @param options The options parameters.
   */
  addCollection(
    jobId: string,
    taskCollection: TaskAddCollectionParameter,
    options?: TaskAddCollectionOptionalParams
  ): Promise<TaskAddCollectionResponse> {
    return this.client.sendOperationRequest(
      { jobId, taskCollection, options },
      addCollectionOperationSpec
    );
  }

  /**
   * When a Task is deleted, all of the files in its directory on the Compute Node where it ran are also
   * deleted (regardless of the retention time). For multi-instance Tasks, the delete Task operation
   * applies synchronously to the primary task; subtasks and their files are then deleted asynchronously
   * in the background.
   * @param jobId The ID of the Job from which to delete the Task.
   * @param taskId The ID of the Task to delete.
   * @param options The options parameters.
   */
  delete(
    jobId: string,
    taskId: string,
    options?: TaskDeleteOptionalParams
  ): Promise<TaskDeleteResponse> {
    return this.client.sendOperationRequest(
      { jobId, taskId, options },
      deleteOperationSpec
    );
  }

  /**
   * For multi-instance Tasks, information such as affinityId, executionInfo and nodeInfo refer to the
   * primary Task. Use the list subtasks API to retrieve information about subtasks.
   * @param jobId The ID of the Job that contains the Task.
   * @param taskId The ID of the Task to get information about.
   * @param options The options parameters.
   */
  get(
    jobId: string,
    taskId: string,
    options?: TaskGetOptionalParams
  ): Promise<TaskGetResponse> {
    return this.client.sendOperationRequest(
      { jobId, taskId, options },
      getOperationSpec
    );
  }

  /**
   * Updates the properties of the specified Task.
   * @param jobId The ID of the Job containing the Task.
   * @param taskId The ID of the Task to update.
   * @param taskUpdateParameter The parameters for the request.
   * @param options The options parameters.
   */
  update(
    jobId: string,
    taskId: string,
    taskUpdateParameter: TaskUpdateParameter,
    options?: TaskUpdateOptionalParams
  ): Promise<TaskUpdateResponse> {
    return this.client.sendOperationRequest(
      { jobId, taskId, taskUpdateParameter, options },
      updateOperationSpec
    );
  }

  /**
   * If the Task is not a multi-instance Task then this returns an empty collection.
   * @param jobId The ID of the Job.
   * @param taskId The ID of the Task.
   * @param options The options parameters.
   */
  listSubtasks(
    jobId: string,
    taskId: string,
    options?: TaskListSubtasksOptionalParams
  ): Promise<TaskListSubtasksResponse> {
    return this.client.sendOperationRequest(
      { jobId, taskId, options },
      listSubtasksOperationSpec
    );
  }

  /**
   * When the Task has been terminated, it moves to the completed state. For multi-instance Tasks, the
   * terminate Task operation applies synchronously to the primary task; subtasks are then terminated
   * asynchronously in the background.
   * @param jobId The ID of the Job containing the Task.
   * @param taskId The ID of the Task to terminate.
   * @param options The options parameters.
   */
  terminate(
    jobId: string,
    taskId: string,
    options?: TaskTerminateOptionalParams
  ): Promise<TaskTerminateResponse> {
    return this.client.sendOperationRequest(
      { jobId, taskId, options },
      terminateOperationSpec
    );
  }

  /**
   * Reactivation makes a Task eligible to be retried again up to its maximum retry count. The Task's
   * state is changed to active. As the Task is no longer in the completed state, any previous exit code
   * or failure information is no longer available after reactivation. Each time a Task is reactivated,
   * its retry count is reset to 0. Reactivation will fail for Tasks that are not completed or that
   * previously completed successfully (with an exit code of 0). Additionally, it will fail if the Job
   * has completed (or is terminating or deleting).
   * @param jobId The ID of the Job containing the Task.
   * @param taskId The ID of the Task to reactivate.
   * @param options The options parameters.
   */
  reactivate(
    jobId: string,
    taskId: string,
    options?: TaskReactivateOptionalParams
  ): Promise<TaskReactivateResponse> {
    return this.client.sendOperationRequest(
      { jobId, taskId, options },
      reactivateOperationSpec
    );
  }

  /**
   * ListNext
   * @param jobId The ID of the Job.
   * @param nextLink The nextLink from the previous successful call to the List method.
   * @param options The options parameters.
   */
  private _listNext(
    jobId: string,
    nextLink: string,
    options?: TaskListNextOptionalParams
  ): Promise<TaskListNextResponse> {
    return this.client.sendOperationRequest(
      { jobId, nextLink, options },
      listNextOperationSpec
    );
  }
}
// Operation Specifications
const serializer = coreClient.createSerializer(Mappers, /* isXml */ false);

const addOperationSpec: coreClient.OperationSpec = {
  path: "/jobs/{jobId}/tasks",
  httpMethod: "POST",
  responses: {
    201: {
      headersMapper: Mappers.TaskAddHeaders
    },
    default: {
      bodyMapper: Mappers.BatchError
    }
  },
  requestBody: Parameters.task,
  queryParameters: [Parameters.apiVersion, Parameters.timeout55],
  urlParameters: [Parameters.batchUrl, Parameters.jobId],
  headerParameters: [
    Parameters.accept,
    Parameters.contentType,
    Parameters.clientRequestId55,
    Parameters.returnClientRequestId55,
    Parameters.ocpDate55
  ],
  mediaType: "json",
  serializer
};
const listOperationSpec: coreClient.OperationSpec = {
  path: "/jobs/{jobId}/tasks",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.CloudTaskListResult,
      headersMapper: Mappers.TaskListHeaders
    },
    default: {
      bodyMapper: Mappers.BatchError
    }
  },
  queryParameters: [
    Parameters.apiVersion,
    Parameters.filter11,
    Parameters.select10,
    Parameters.expand7,
    Parameters.maxResults12,
    Parameters.timeout56
  ],
  urlParameters: [Parameters.batchUrl, Parameters.jobId],
  headerParameters: [
    Parameters.accept,
    Parameters.clientRequestId56,
    Parameters.returnClientRequestId56,
    Parameters.ocpDate56
  ],
  serializer
};
const addCollectionOperationSpec: coreClient.OperationSpec = {
  path: "/jobs/{jobId}/addtaskcollection",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.TaskAddCollectionResult,
      headersMapper: Mappers.TaskAddCollectionHeaders
    },
    default: {
      bodyMapper: Mappers.BatchError
    }
  },
  requestBody: Parameters.taskCollection,
  queryParameters: [Parameters.apiVersion, Parameters.timeout57],
  urlParameters: [Parameters.batchUrl, Parameters.jobId],
  headerParameters: [
    Parameters.accept,
    Parameters.contentType,
    Parameters.clientRequestId57,
    Parameters.returnClientRequestId57,
    Parameters.ocpDate57
  ],
  mediaType: "json",
  serializer
};
const deleteOperationSpec: coreClient.OperationSpec = {
  path: "/jobs/{jobId}/tasks/{taskId}",
  httpMethod: "DELETE",
  responses: {
    200: {
      headersMapper: Mappers.TaskDeleteHeaders
    },
    default: {
      bodyMapper: Mappers.BatchError
    }
  },
  queryParameters: [Parameters.apiVersion, Parameters.timeout58],
  urlParameters: [Parameters.batchUrl, Parameters.jobId, Parameters.taskId],
  headerParameters: [
    Parameters.accept,
    Parameters.clientRequestId58,
    Parameters.returnClientRequestId58,
    Parameters.ocpDate58,
    Parameters.ifMatch23,
    Parameters.ifNoneMatch23,
    Parameters.ifModifiedSince27,
    Parameters.ifUnmodifiedSince27
  ],
  serializer
};
const getOperationSpec: coreClient.OperationSpec = {
  path: "/jobs/{jobId}/tasks/{taskId}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.CloudTask,
      headersMapper: Mappers.TaskGetHeaders
    },
    default: {
      bodyMapper: Mappers.BatchError
    }
  },
  queryParameters: [
    Parameters.apiVersion,
    Parameters.select11,
    Parameters.expand8,
    Parameters.timeout59
  ],
  urlParameters: [Parameters.batchUrl, Parameters.jobId, Parameters.taskId],
  headerParameters: [
    Parameters.accept,
    Parameters.clientRequestId59,
    Parameters.returnClientRequestId59,
    Parameters.ocpDate59,
    Parameters.ifMatch24,
    Parameters.ifNoneMatch24,
    Parameters.ifModifiedSince28,
    Parameters.ifUnmodifiedSince28
  ],
  serializer
};
const updateOperationSpec: coreClient.OperationSpec = {
  path: "/jobs/{jobId}/tasks/{taskId}",
  httpMethod: "PUT",
  responses: {
    200: {
      headersMapper: Mappers.TaskUpdateHeaders
    },
    default: {
      bodyMapper: Mappers.BatchError
    }
  },
  requestBody: Parameters.taskUpdateParameter,
  queryParameters: [Parameters.apiVersion, Parameters.timeout60],
  urlParameters: [Parameters.batchUrl, Parameters.jobId, Parameters.taskId],
  headerParameters: [
    Parameters.accept,
    Parameters.contentType,
    Parameters.clientRequestId60,
    Parameters.returnClientRequestId60,
    Parameters.ocpDate60,
    Parameters.ifMatch25,
    Parameters.ifNoneMatch25,
    Parameters.ifModifiedSince29,
    Parameters.ifUnmodifiedSince29
  ],
  mediaType: "json",
  serializer
};
const listSubtasksOperationSpec: coreClient.OperationSpec = {
  path: "/jobs/{jobId}/tasks/{taskId}/subtasksinfo",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.CloudTaskListSubtasksResult,
      headersMapper: Mappers.TaskListSubtasksHeaders
    },
    default: {
      bodyMapper: Mappers.BatchError
    }
  },
  queryParameters: [
    Parameters.apiVersion,
    Parameters.select12,
    Parameters.timeout61
  ],
  urlParameters: [Parameters.batchUrl, Parameters.jobId, Parameters.taskId],
  headerParameters: [
    Parameters.accept,
    Parameters.clientRequestId61,
    Parameters.returnClientRequestId61,
    Parameters.ocpDate61
  ],
  serializer
};
const terminateOperationSpec: coreClient.OperationSpec = {
  path: "/jobs/{jobId}/tasks/{taskId}/terminate",
  httpMethod: "POST",
  responses: {
    204: {
      headersMapper: Mappers.TaskTerminateHeaders
    },
    default: {
      bodyMapper: Mappers.BatchError
    }
  },
  queryParameters: [Parameters.apiVersion, Parameters.timeout62],
  urlParameters: [Parameters.batchUrl, Parameters.jobId, Parameters.taskId],
  headerParameters: [
    Parameters.accept,
    Parameters.clientRequestId62,
    Parameters.returnClientRequestId62,
    Parameters.ocpDate62,
    Parameters.ifMatch26,
    Parameters.ifNoneMatch26,
    Parameters.ifModifiedSince30,
    Parameters.ifUnmodifiedSince30
  ],
  serializer
};
const reactivateOperationSpec: coreClient.OperationSpec = {
  path: "/jobs/{jobId}/tasks/{taskId}/reactivate",
  httpMethod: "POST",
  responses: {
    204: {
      headersMapper: Mappers.TaskReactivateHeaders
    },
    default: {
      bodyMapper: Mappers.BatchError
    }
  },
  queryParameters: [Parameters.apiVersion, Parameters.timeout63],
  urlParameters: [Parameters.batchUrl, Parameters.jobId, Parameters.taskId],
  headerParameters: [
    Parameters.accept,
    Parameters.clientRequestId63,
    Parameters.returnClientRequestId63,
    Parameters.ocpDate63,
    Parameters.ifMatch27,
    Parameters.ifNoneMatch27,
    Parameters.ifModifiedSince31,
    Parameters.ifUnmodifiedSince31
  ],
  serializer
};
const listNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.CloudTaskListResult,
      headersMapper: Mappers.TaskListNextHeaders
    },
    default: {
      bodyMapper: Mappers.BatchError
    }
  },
  queryParameters: [
    Parameters.apiVersion,
    Parameters.filter11,
    Parameters.select10,
    Parameters.expand7,
    Parameters.maxResults12,
    Parameters.timeout56
  ],
  urlParameters: [Parameters.batchUrl, Parameters.nextLink, Parameters.jobId],
  headerParameters: [
    Parameters.accept,
    Parameters.clientRequestId56,
    Parameters.returnClientRequestId56,
    Parameters.ocpDate56
  ],
  serializer
};
