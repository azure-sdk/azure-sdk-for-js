## API Report File for "@azure/arm-azuredatatransfer"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import * as coreAuth from '@azure/core-auth';
import * as coreClient from '@azure/core-client';
import { OperationState } from '@azure/core-lro';
import { PagedAsyncIterableIterator } from '@azure/core-paging';
import { SimplePollerLike } from '@azure/core-lro';

// @public
export interface Action {
    actionType: ActionType;
    justification?: string;
    targets: string[];
    targetType: TargetType;
}

// @public
export type ActionType = string;

// @public
export interface ApiFlowOptions {
    apiMode?: ApiMode;
    audienceOverride?: string;
    cname?: string;
    identityTranslation?: IdentityTranslation;
    remoteCallingModeClientId?: string;
    remoteEndpoint?: string;
    senderClientId?: string;
}

// @public
export type ApiMode = string;

// @public
export interface AzureDataTransfer {
    listApprovedSchemas(pipeline: ListApprovedSchemasRequest, options?: AzureDataTransferListApprovedSchemasOptionalParams): Promise<AzureDataTransferListApprovedSchemasResponse>;
    validateSchema(schema: Schema, options?: AzureDataTransferValidateSchemaOptionalParams): Promise<AzureDataTransferValidateSchemaResponse>;
}

// @public
export interface AzureDataTransferListApprovedSchemasOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AzureDataTransferListApprovedSchemasResponse = SchemasListResult;

// @public (undocumented)
export class Azuredatatransferrp extends coreClient.ServiceClient {
    // (undocumented)
    $host: string;
    constructor(credentials: coreAuth.TokenCredential, subscriptionId: string, options?: AzuredatatransferrpOptionalParams);
    constructor(credentials: coreAuth.TokenCredential, options?: AzuredatatransferrpOptionalParams);
    // (undocumented)
    apiVersion: string;
    // (undocumented)
    azureDataTransfer: AzureDataTransfer;
    // (undocumented)
    connections: Connections;
    // (undocumented)
    flows: Flows;
    // (undocumented)
    listFlowsByPipeline: ListFlowsByPipeline;
    // (undocumented)
    listPendingConnections: ListPendingConnections;
    // (undocumented)
    listPendingFlows: ListPendingFlows;
    // (undocumented)
    listSchemas: ListSchemas;
    // (undocumented)
    operations: Operations;
    // (undocumented)
    pipelines: Pipelines;
    // (undocumented)
    subscriptionId?: string;
}

// @public
export interface AzuredatatransferrpOptionalParams extends coreClient.ServiceClientOptions {
    $host?: string;
    apiVersion?: string;
    endpoint?: string;
}

// @public
export interface AzureDataTransferValidateSchemaOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AzureDataTransferValidateSchemaResponse = ValidateSchemaResult;

// @public
export interface Connection extends TrackedResource {
    identity?: ManagedServiceIdentity;
    properties?: ConnectionProperties;
}

// @public (undocumented)
export interface ConnectionIdList {
    value?: string[];
}

// @public
export interface ConnectionProperties {
    readonly approver?: string;
    readonly dateSubmitted?: Date;
    direction?: Direction;
    flowTypes?: FlowType[];
    readonly forceDisabledStatus?: ForceDisabledStatus[];
    justification?: string;
    readonly linkedConnectionId?: string;
    readonly linkStatus?: LinkStatus;
    pin?: string;
    pipeline: string;
    policies?: string[];
    primaryContact?: string;
    readonly provisioningState?: ProvisioningState;
    remoteSubscriptionId?: string;
    requirementId?: string;
    schemas?: Schema[];
    schemaUris?: string[];
    secondaryContacts?: string[];
    readonly status?: Status;
    readonly statusReason?: string;
}

// @public
export interface Connections {
    beginCreateOrUpdate(resourceGroupName: string, connectionName: string, connection: Connection, options?: ConnectionsCreateOrUpdateOptionalParams): Promise<SimplePollerLike<OperationState<ConnectionsCreateOrUpdateResponse>, ConnectionsCreateOrUpdateResponse>>;
    beginCreateOrUpdateAndWait(resourceGroupName: string, connectionName: string, connection: Connection, options?: ConnectionsCreateOrUpdateOptionalParams): Promise<ConnectionsCreateOrUpdateResponse>;
    beginDelete(resourceGroupName: string, connectionName: string, options?: ConnectionsDeleteOptionalParams): Promise<SimplePollerLike<OperationState<ConnectionsDeleteResponse>, ConnectionsDeleteResponse>>;
    beginDeleteAndWait(resourceGroupName: string, connectionName: string, options?: ConnectionsDeleteOptionalParams): Promise<ConnectionsDeleteResponse>;
    beginLink(resourceGroupName: string, connectionName: string, connection: ResourceBody, options?: ConnectionsLinkOptionalParams): Promise<SimplePollerLike<OperationState<ConnectionsLinkResponse>, ConnectionsLinkResponse>>;
    beginLinkAndWait(resourceGroupName: string, connectionName: string, connection: ResourceBody, options?: ConnectionsLinkOptionalParams): Promise<ConnectionsLinkResponse>;
    beginUpdate(resourceGroupName: string, connectionName: string, connection: ConnectionsPatch, options?: ConnectionsUpdateOptionalParams): Promise<SimplePollerLike<OperationState<ConnectionsUpdateResponse>, ConnectionsUpdateResponse>>;
    beginUpdateAndWait(resourceGroupName: string, connectionName: string, connection: ConnectionsPatch, options?: ConnectionsUpdateOptionalParams): Promise<ConnectionsUpdateResponse>;
    get(resourceGroupName: string, connectionName: string, options?: ConnectionsGetOptionalParams): Promise<ConnectionsGetResponse>;
    listByResourceGroup(resourceGroupName: string, options?: ConnectionsListByResourceGroupOptionalParams): PagedAsyncIterableIterator<Connection>;
    listBySubscription(options?: ConnectionsListBySubscriptionOptionalParams): PagedAsyncIterableIterator<Connection>;
}

// @public
export interface ConnectionsCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type ConnectionsCreateOrUpdateResponse = Connection;

// @public
export interface ConnectionsDeleteHeaders {
    location?: string;
}

// @public
export interface ConnectionsDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type ConnectionsDeleteResponse = ConnectionsDeleteHeaders;

// @public
export interface ConnectionsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ConnectionsGetResponse = Connection;

// @public
export interface ConnectionsLinkHeaders {
    location?: string;
}

// @public
export interface ConnectionsLinkOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type ConnectionsLinkResponse = Connection;

// @public
export interface ConnectionsListByResourceGroupNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ConnectionsListByResourceGroupNextResponse = ConnectionsListResult;

// @public
export interface ConnectionsListByResourceGroupOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ConnectionsListByResourceGroupResponse = ConnectionsListResult;

// @public
export interface ConnectionsListBySubscriptionNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ConnectionsListBySubscriptionNextResponse = ConnectionsListResult;

// @public
export interface ConnectionsListBySubscriptionOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ConnectionsListBySubscriptionResponse = ConnectionsListResult;

// @public
export interface ConnectionsListResult {
    nextLink?: string;
    value?: Connection[];
}

// @public
export interface ConnectionsPatch {
    identity?: ManagedServiceIdentity;
    tags?: {
        [propertyName: string]: string;
    };
}

// @public
export interface ConnectionsUpdateHeaders {
    location?: string;
}

// @public
export interface ConnectionsUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type ConnectionsUpdateResponse = Connection;

// @public
export type CreatedByType = string;

// @public
export type DataType = string;

// @public
export type Direction = string;

// @public
export interface ErrorAdditionalInfo {
    readonly info?: Record<string, unknown>;
    readonly type?: string;
}

// @public
export interface ErrorDetail {
    readonly additionalInfo?: ErrorAdditionalInfo[];
    readonly code?: string;
    readonly details?: ErrorDetail[];
    readonly message?: string;
    readonly target?: string;
}

// @public
export interface ErrorResponse {
    error?: ErrorDetail;
}

// @public
export interface Flow extends TrackedResource {
    identity?: ManagedServiceIdentity;
    plan?: Plan;
    properties?: FlowProperties;
}

// @public
export type FlowBillingTier = string;

// @public
export interface FlowProperties {
    apiFlowOptions?: ApiFlowOptions;
    connection?: SelectedResource;
    consumerGroup?: string;
    customerManagedKeyVaultUri?: string;
    dataType?: DataType;
    destinationEndpointPorts?: number[];
    destinationEndpoints?: string[];
    eventHubId?: string;
    readonly flowId?: string;
    flowType?: FlowType;
    readonly forceDisabledStatus?: ForceDisabledStatus[];
    keyVaultUri?: string;
    readonly linkedFlowId?: string;
    readonly linkStatus?: LinkStatusFlow;
    messagingOptions?: MessagingOptions;
    passphrase?: string;
    policies?: string[];
    readonly provisioningState?: ProvisioningState;
    schema?: Schema;
    serviceBusQueueId?: string;
    sourceAddresses?: StreamSourceAddresses;
    status?: FlowStatus;
    storageAccountId?: string;
    storageAccountName?: string;
    storageContainerName?: string;
    storageTableName?: string;
    streamId?: string;
    streamLatency?: number;
    streamProtocol?: StreamProtocol;
}

// @public
export interface Flows {
    beginCreateOrUpdate(resourceGroupName: string, connectionName: string, flowName: string, flow: Flow, options?: FlowsCreateOrUpdateOptionalParams): Promise<SimplePollerLike<OperationState<FlowsCreateOrUpdateResponse>, FlowsCreateOrUpdateResponse>>;
    beginCreateOrUpdateAndWait(resourceGroupName: string, connectionName: string, flowName: string, flow: Flow, options?: FlowsCreateOrUpdateOptionalParams): Promise<FlowsCreateOrUpdateResponse>;
    beginDelete(resourceGroupName: string, connectionName: string, flowName: string, options?: FlowsDeleteOptionalParams): Promise<SimplePollerLike<OperationState<FlowsDeleteResponse>, FlowsDeleteResponse>>;
    beginDeleteAndWait(resourceGroupName: string, connectionName: string, flowName: string, options?: FlowsDeleteOptionalParams): Promise<FlowsDeleteResponse>;
    beginDisable(resourceGroupName: string, connectionName: string, flowName: string, options?: FlowsDisableOptionalParams): Promise<SimplePollerLike<OperationState<FlowsDisableResponse>, FlowsDisableResponse>>;
    beginDisableAndWait(resourceGroupName: string, connectionName: string, flowName: string, options?: FlowsDisableOptionalParams): Promise<FlowsDisableResponse>;
    beginEnable(resourceGroupName: string, connectionName: string, flowName: string, options?: FlowsEnableOptionalParams): Promise<SimplePollerLike<OperationState<FlowsEnableResponse>, FlowsEnableResponse>>;
    beginEnableAndWait(resourceGroupName: string, connectionName: string, flowName: string, options?: FlowsEnableOptionalParams): Promise<FlowsEnableResponse>;
    beginGeneratePassphrase(resourceGroupName: string, connectionName: string, flowName: string, options?: FlowsGeneratePassphraseOptionalParams): Promise<SimplePollerLike<OperationState<FlowsGeneratePassphraseResponse>, FlowsGeneratePassphraseResponse>>;
    beginGeneratePassphraseAndWait(resourceGroupName: string, connectionName: string, flowName: string, options?: FlowsGeneratePassphraseOptionalParams): Promise<FlowsGeneratePassphraseResponse>;
    beginLink(resourceGroupName: string, connectionName: string, flowName: string, flow: ResourceBody, options?: FlowsLinkOptionalParams): Promise<SimplePollerLike<OperationState<FlowsLinkResponse>, FlowsLinkResponse>>;
    beginLinkAndWait(resourceGroupName: string, connectionName: string, flowName: string, flow: ResourceBody, options?: FlowsLinkOptionalParams): Promise<FlowsLinkResponse>;
    beginSetDestinationEndpointPorts(resourceGroupName: string, connectionName: string, flowName: string, streamDestinationEndpointPorts: SetDestinationEndpointPorts, options?: FlowsSetDestinationEndpointPortsOptionalParams): Promise<SimplePollerLike<OperationState<FlowsSetDestinationEndpointPortsResponse>, FlowsSetDestinationEndpointPortsResponse>>;
    beginSetDestinationEndpointPortsAndWait(resourceGroupName: string, connectionName: string, flowName: string, streamDestinationEndpointPorts: SetDestinationEndpointPorts, options?: FlowsSetDestinationEndpointPortsOptionalParams): Promise<FlowsSetDestinationEndpointPortsResponse>;
    beginSetDestinationEndpoints(resourceGroupName: string, connectionName: string, flowName: string, streamDestinationEndpoints: SetDestinationEndpoints, options?: FlowsSetDestinationEndpointsOptionalParams): Promise<SimplePollerLike<OperationState<FlowsSetDestinationEndpointsResponse>, FlowsSetDestinationEndpointsResponse>>;
    beginSetDestinationEndpointsAndWait(resourceGroupName: string, connectionName: string, flowName: string, streamDestinationEndpoints: SetDestinationEndpoints, options?: FlowsSetDestinationEndpointsOptionalParams): Promise<FlowsSetDestinationEndpointsResponse>;
    beginSetPassphrase(resourceGroupName: string, connectionName: string, flowName: string, passphrase: SetStreamPassphrase, options?: FlowsSetPassphraseOptionalParams): Promise<SimplePollerLike<OperationState<FlowsSetPassphraseResponse>, FlowsSetPassphraseResponse>>;
    beginSetPassphraseAndWait(resourceGroupName: string, connectionName: string, flowName: string, passphrase: SetStreamPassphrase, options?: FlowsSetPassphraseOptionalParams): Promise<FlowsSetPassphraseResponse>;
    beginSetSourceAddresses(resourceGroupName: string, connectionName: string, flowName: string, sourceAddresses: SetSourceAddresses, options?: FlowsSetSourceAddressesOptionalParams): Promise<SimplePollerLike<OperationState<FlowsSetSourceAddressesResponse>, FlowsSetSourceAddressesResponse>>;
    beginSetSourceAddressesAndWait(resourceGroupName: string, connectionName: string, flowName: string, sourceAddresses: SetSourceAddresses, options?: FlowsSetSourceAddressesOptionalParams): Promise<FlowsSetSourceAddressesResponse>;
    beginUpdate(resourceGroupName: string, connectionName: string, flowName: string, flow: FlowsPatch, options?: FlowsUpdateOptionalParams): Promise<SimplePollerLike<OperationState<FlowsUpdateResponse>, FlowsUpdateResponse>>;
    beginUpdateAndWait(resourceGroupName: string, connectionName: string, flowName: string, flow: FlowsPatch, options?: FlowsUpdateOptionalParams): Promise<FlowsUpdateResponse>;
    get(resourceGroupName: string, connectionName: string, flowName: string, options?: FlowsGetOptionalParams): Promise<FlowsGetResponse>;
    getDestinationEndpointPorts(resourceGroupName: string, connectionName: string, flowName: string, options?: FlowsGetDestinationEndpointPortsOptionalParams): Promise<FlowsGetDestinationEndpointPortsResponse>;
    getDestinationEndpoints(resourceGroupName: string, connectionName: string, flowName: string, options?: FlowsGetDestinationEndpointsOptionalParams): Promise<FlowsGetDestinationEndpointsResponse>;
    getSourceAddresses(resourceGroupName: string, connectionName: string, flowName: string, options?: FlowsGetSourceAddressesOptionalParams): Promise<FlowsGetSourceAddressesResponse>;
    getStreamConnectionString(resourceGroupName: string, connectionName: string, flowName: string, options?: FlowsGetStreamConnectionStringOptionalParams): Promise<FlowsGetStreamConnectionStringResponse>;
    listByConnection(resourceGroupName: string, connectionName: string, options?: FlowsListByConnectionOptionalParams): PagedAsyncIterableIterator<Flow>;
}

// @public
export interface FlowsCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type FlowsCreateOrUpdateResponse = Flow;

// @public
export interface FlowsDeleteHeaders {
    location?: string;
}

// @public
export interface FlowsDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type FlowsDeleteResponse = FlowsDeleteHeaders;

// @public
export interface FlowsDisableHeaders {
    location?: string;
}

// @public
export interface FlowsDisableOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type FlowsDisableResponse = Flow;

// @public
export interface FlowsEnableHeaders {
    location?: string;
}

// @public
export interface FlowsEnableOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type FlowsEnableResponse = Flow;

// @public
export interface FlowsGeneratePassphraseHeaders {
    location?: string;
}

// @public
export interface FlowsGeneratePassphraseOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type FlowsGeneratePassphraseResponse = Flow;

// @public
export interface FlowsGetDestinationEndpointPortsOptionalParams extends coreClient.OperationOptions {
}

// @public
export type FlowsGetDestinationEndpointPortsResponse = GetDestinationEndpointPortsResult;

// @public
export interface FlowsGetDestinationEndpointsOptionalParams extends coreClient.OperationOptions {
}

// @public
export type FlowsGetDestinationEndpointsResponse = GetDestinationEndpointsResult;

// @public
export interface FlowsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type FlowsGetResponse = Flow;

// @public
export interface FlowsGetSourceAddressesOptionalParams extends coreClient.OperationOptions {
}

// @public
export type FlowsGetSourceAddressesResponse = StreamSourceAddresses;

// @public
export interface FlowsGetStreamConnectionStringOptionalParams extends coreClient.OperationOptions {
}

// @public
export type FlowsGetStreamConnectionStringResponse = GetStreamConnectionStringResult;

// @public
export interface FlowsLinkHeaders {
    location?: string;
}

// @public
export interface FlowsLinkOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type FlowsLinkResponse = Flow;

// @public
export interface FlowsListByConnectionNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type FlowsListByConnectionNextResponse = FlowsListResult;

// @public
export interface FlowsListByConnectionOptionalParams extends coreClient.OperationOptions {
}

// @public
export type FlowsListByConnectionResponse = FlowsListResult;

// @public
export interface FlowsListResult {
    nextLink?: string;
    value?: Flow[];
}

// @public
export interface FlowsPatch {
    identity?: ManagedServiceIdentity;
    tags?: {
        [propertyName: string]: string;
    };
}

// @public
export interface FlowsSetDestinationEndpointPortsHeaders {
    location?: string;
}

// @public
export interface FlowsSetDestinationEndpointPortsOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type FlowsSetDestinationEndpointPortsResponse = Flow;

// @public
export interface FlowsSetDestinationEndpointsHeaders {
    location?: string;
}

// @public
export interface FlowsSetDestinationEndpointsOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type FlowsSetDestinationEndpointsResponse = Flow;

// @public
export interface FlowsSetPassphraseHeaders {
    location?: string;
}

// @public
export interface FlowsSetPassphraseOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type FlowsSetPassphraseResponse = Flow;

// @public
export interface FlowsSetSourceAddressesHeaders {
    location?: string;
}

// @public
export interface FlowsSetSourceAddressesOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type FlowsSetSourceAddressesResponse = Flow;

// @public
export type FlowStatus = string;

// @public
export interface FlowsUpdateHeaders {
    location?: string;
}

// @public
export interface FlowsUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type FlowsUpdateResponse = Flow;

// @public
export type FlowType = string;

// @public
export type ForceDisabledStatus = string;

// @public
export function getContinuationToken(page: unknown): string | undefined;

// @public
export interface GetDestinationEndpointPortsResult {
    ports?: number[];
}

// @public
export interface GetDestinationEndpointsResult {
    endpoints?: string[];
}

// @public
export interface GetStreamConnectionStringResult {
    connectionString?: string;
}

// @public
export type IdentityTranslation = string;

// @public
export interface InternalMetadataProperties {
    [property: string]: any;
    operationStatus?: OperationStatusProperties;
    readonly statusSetBy?: string;
}

// @public
export enum KnownActionType {
    AllowUpdates = "AllowUpdates",
    ForceDisable = "ForceDisable",
    Internal = "Internal"
}

// @public
export enum KnownApiMode {
    Endpoint = "Endpoint",
    SDK = "SDK"
}

// @public
export enum KnownCreatedByType {
    Application = "Application",
    Key = "Key",
    ManagedIdentity = "ManagedIdentity",
    User = "User"
}

// @public
export enum KnownDataType {
    Blob = "Blob",
    Table = "Table"
}

// @public
export enum KnownDirection {
    Receive = "Receive",
    Send = "Send"
}

// @public
export enum KnownFlowBillingTier {
    BlobTransport = "BlobTransport",
    Premium = "Premium",
    Standard = "Standard"
}

// @public
export enum KnownFlowStatus {
    Disabled = "Disabled",
    Enabled = "Enabled"
}

// @public
export enum KnownFlowType {
    API = "API",
    BasicFiles = "BasicFiles",
    Complex = "Complex",
    Data = "Data",
    DevSecOps = "DevSecOps",
    DiskImages = "DiskImages",
    Messaging = "Messaging",
    MicrosoftInternal = "MicrosoftInternal",
    Mission = "Mission",
    MissionOpaqueXML = "MissionOpaqueXML",
    Opaque = "Opaque",
    Standard = "Standard",
    StreamingVideo = "StreamingVideo",
    Unknown = "Unknown"
}

// @public
export enum KnownForceDisabledStatus {
    ConnectionForceDisabled = "ConnectionForceDisabled",
    FlowTypeForceDisabled = "FlowTypeForceDisabled"
}

// @public
export enum KnownIdentityTranslation {
    ServiceIdentity = "ServiceIdentity",
    UserIdentity = "UserIdentity"
}

// @public
export enum KnownLinkStatus {
    Linked = "Linked",
    Unlinked = "Unlinked"
}

// @public
export enum KnownLinkStatusFlow {
    Linked = "Linked",
    Unlinked = "Unlinked"
}

// @public
export enum KnownListApprovedSchemasDirection {
    Receive = "Receive",
    Send = "Send"
}

// @public
export enum KnownManagedServiceIdentityType {
    None = "None",
    SystemAssigned = "SystemAssigned",
    SystemAssignedUserAssigned = "SystemAssigned,UserAssigned",
    UserAssigned = "UserAssigned"
}

// @public
export enum KnownOperationStatusEnum {
    Failed = "Failed",
    Succeeded = "Succeeded"
}

// @public
export enum KnownOrigin {
    System = "system",
    User = "user",
    UserSystem = "user,system"
}

// @public
export enum KnownPipelineStatus {
    Disabled = "Disabled",
    Enabled = "Enabled"
}

// @public
export enum KnownProvisioningState {
    Accepted = "Accepted",
    Canceled = "Canceled",
    Failed = "Failed",
    Succeeded = "Succeeded"
}

// @public
export enum KnownSchemaDirection {
    Receive = "Receive",
    Send = "Send"
}

// @public
export enum KnownSchemaStatus {
    Approved = "Approved",
    New = "New"
}

// @public
export enum KnownSchemaType {
    Xsd = "Xsd",
    Zip = "Zip"
}

// @public
export enum KnownStatus {
    Accepted = "Accepted",
    Approved = "Approved",
    InReview = "InReview",
    Rejected = "Rejected"
}

// @public
export enum KnownStreamProtocol {
    RTP = "RTP",
    SRT = "SRT",
    UDP = "UDP"
}

// @public
export enum KnownTargetType {
    Connection = "Connection",
    FlowType = "FlowType",
    Pipeline = "Pipeline"
}

// @public
export enum KnownValidateSchemaStatus {
    Failed = "Failed",
    Succeeded = "Succeeded"
}

// @public
export type LinkStatus = string;

// @public
export type LinkStatusFlow = string;

// @public
export type ListApprovedSchemasDirection = string;

// @public (undocumented)
export interface ListApprovedSchemasRequest {
    direction?: ListApprovedSchemasDirection;
    pipeline?: string;
}

// @public
export interface ListFlowsByPipeline {
    list(resourceGroupName: string, pipelineName: string, options?: ListFlowsByPipelineListOptionalParams): Promise<ListFlowsByPipelineListResponse>;
}

// @public (undocumented)
export interface ListFlowsByPipelineConnection {
    flows?: Flow[];
    id?: string;
}

// @public
export interface ListFlowsByPipelineListOptionalParams extends coreClient.OperationOptions {
    connections?: ConnectionIdList;
}

// @public
export type ListFlowsByPipelineListResponse = ListFlowsByPipelineResult;

// @public (undocumented)
export interface ListFlowsByPipelineResult {
    value?: ListFlowsByPipelineConnection[];
}

// @public
export interface ListPendingConnections {
    list(resourceGroupName: string, connectionName: string, options?: ListPendingConnectionsListOptionalParams): PagedAsyncIterableIterator<PendingConnection>;
}

// @public
export interface ListPendingConnectionsListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ListPendingConnectionsListNextResponse = PendingConnectionsListResult;

// @public
export interface ListPendingConnectionsListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ListPendingConnectionsListResponse = PendingConnectionsListResult;

// @public
export interface ListPendingFlows {
    list(resourceGroupName: string, connectionName: string, options?: ListPendingFlowsListOptionalParams): PagedAsyncIterableIterator<PendingFlow>;
}

// @public
export interface ListPendingFlowsListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ListPendingFlowsListNextResponse = PendingFlowsListResult;

// @public
export interface ListPendingFlowsListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ListPendingFlowsListResponse = PendingFlowsListResult;

// @public
export interface ListSchemas {
    list(resourceGroupName: string, pipelineName: string, schema: Schema, options?: ListSchemasListOptionalParams): Promise<ListSchemasListResponse>;
}

// @public
export interface ListSchemasListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ListSchemasListResponse = SchemasListResult;

// @public
export interface ManagedServiceIdentity {
    readonly principalId?: string;
    readonly tenantId?: string;
    type: ManagedServiceIdentityType;
    userAssignedIdentities?: {
        [propertyName: string]: UserAssignedIdentity;
    };
}

// @public
export type ManagedServiceIdentityType = string;

// @public
export interface MessagingOptions {
    billingTier?: FlowBillingTier;
}

// @public
export interface Operation {
    readonly actionType?: ActionType;
    display?: OperationDisplay;
    readonly isDataAction?: boolean;
    readonly name?: string;
    readonly origin?: Origin;
}

// @public
export interface OperationDisplay {
    readonly description?: string;
    readonly operation?: string;
    readonly provider?: string;
    readonly resource?: string;
}

// @public
export interface OperationListResult {
    readonly nextLink?: string;
    readonly value?: Operation[];
}

// @public
export interface Operations {
    list(options?: OperationsListOptionalParams): PagedAsyncIterableIterator<Operation>;
}

// @public
export interface OperationsListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type OperationsListNextResponse = OperationListResult;

// @public
export interface OperationsListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type OperationsListResponse = OperationListResult;

// @public
export type OperationStatusEnum = string;

// @public
export interface OperationStatusProperties {
    readonly id?: string;
    readonly message?: string;
    readonly status?: OperationStatusEnum;
}

// @public
export type Origin = string;

// @public
export interface PendingConnection extends ConnectionProperties, TrackedResource {
    readonly subscriptionId?: string;
}

// @public
export interface PendingConnectionsListResult {
    nextLink?: string;
    value?: PendingConnection[];
}

// @public
export interface PendingFlow extends FlowProperties, TrackedResource {
    readonly connectionId?: string;
    readonly subscriptionId?: string;
}

// @public
export interface PendingFlowsListResult {
    nextLink?: string;
    value?: PendingFlow[];
}

// @public
export interface Pipeline extends TrackedResource {
    identity?: ManagedServiceIdentity;
    properties?: PipelineProperties;
}

// @public
export interface PipelineConnection {
    [property: string]: any;
    readonly etag?: string;
    id: string;
    readonly location?: string;
    readonly name?: string;
    properties?: PipelineConnectionProperties;
    readonly systemData?: SystemData;
    readonly type?: string;
}

// @public
export interface PipelineConnectionProperties {
    [property: string]: any;
    internalMetadata?: InternalMetadataProperties;
}

// @public
export interface PipelineProperties {
    readonly connections?: PipelineConnection[];
    disabledFlowTypes?: FlowType[];
    displayName?: string;
    flowTypes?: FlowType[];
    policies?: string[];
    readonly provisioningState?: ProvisioningState;
    quarantineDownloadStorageAccount?: string;
    quarantineDownloadStorageContainer?: string;
    remoteCloud: string;
    status?: PipelineStatus;
    subscribers?: Subscriber[];
}

// @public
export interface Pipelines {
    beginApproveConnection(resourceGroupName: string, pipelineName: string, connection: ResourceBody, options?: PipelinesApproveConnectionOptionalParams): Promise<SimplePollerLike<OperationState<PipelinesApproveConnectionResponse>, PipelinesApproveConnectionResponse>>;
    beginApproveConnectionAndWait(resourceGroupName: string, pipelineName: string, connection: ResourceBody, options?: PipelinesApproveConnectionOptionalParams): Promise<PipelinesApproveConnectionResponse>;
    beginCreateOrUpdate(resourceGroupName: string, pipelineName: string, pipeline: Pipeline, options?: PipelinesCreateOrUpdateOptionalParams): Promise<SimplePollerLike<OperationState<PipelinesCreateOrUpdateResponse>, PipelinesCreateOrUpdateResponse>>;
    beginCreateOrUpdateAndWait(resourceGroupName: string, pipelineName: string, pipeline: Pipeline, options?: PipelinesCreateOrUpdateOptionalParams): Promise<PipelinesCreateOrUpdateResponse>;
    beginDelete(resourceGroupName: string, pipelineName: string, options?: PipelinesDeleteOptionalParams): Promise<SimplePollerLike<OperationState<PipelinesDeleteResponse>, PipelinesDeleteResponse>>;
    beginDeleteAndWait(resourceGroupName: string, pipelineName: string, options?: PipelinesDeleteOptionalParams): Promise<PipelinesDeleteResponse>;
    beginExecuteAction(resourceGroupName: string, pipelineName: string, action: Action, options?: PipelinesExecuteActionOptionalParams): Promise<SimplePollerLike<OperationState<PipelinesExecuteActionResponse>, PipelinesExecuteActionResponse>>;
    beginExecuteActionAndWait(resourceGroupName: string, pipelineName: string, action: Action, options?: PipelinesExecuteActionOptionalParams): Promise<PipelinesExecuteActionResponse>;
    beginRejectConnection(resourceGroupName: string, pipelineName: string, connection: ResourceBody, options?: PipelinesRejectConnectionOptionalParams): Promise<SimplePollerLike<OperationState<PipelinesRejectConnectionResponse>, PipelinesRejectConnectionResponse>>;
    beginRejectConnectionAndWait(resourceGroupName: string, pipelineName: string, connection: ResourceBody, options?: PipelinesRejectConnectionOptionalParams): Promise<PipelinesRejectConnectionResponse>;
    beginUpdate(resourceGroupName: string, pipelineName: string, pipeline: PipelinesPatch, options?: PipelinesUpdateOptionalParams): Promise<SimplePollerLike<OperationState<PipelinesUpdateResponse>, PipelinesUpdateResponse>>;
    beginUpdateAndWait(resourceGroupName: string, pipelineName: string, pipeline: PipelinesPatch, options?: PipelinesUpdateOptionalParams): Promise<PipelinesUpdateResponse>;
    get(resourceGroupName: string, pipelineName: string, options?: PipelinesGetOptionalParams): Promise<PipelinesGetResponse>;
    listByResourceGroup(resourceGroupName: string, options?: PipelinesListByResourceGroupOptionalParams): PagedAsyncIterableIterator<Pipeline>;
    listBySubscription(options?: PipelinesListBySubscriptionOptionalParams): PagedAsyncIterableIterator<Pipeline>;
}

// @public
export interface PipelinesApproveConnectionHeaders {
    location?: string;
}

// @public
export interface PipelinesApproveConnectionOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type PipelinesApproveConnectionResponse = Connection;

// @public
export interface PipelinesCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type PipelinesCreateOrUpdateResponse = Pipeline;

// @public
export interface PipelinesDeleteHeaders {
    location?: string;
}

// @public
export interface PipelinesDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type PipelinesDeleteResponse = PipelinesDeleteHeaders;

// @public
export interface PipelinesExecuteActionHeaders {
    location?: string;
}

// @public
export interface PipelinesExecuteActionOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type PipelinesExecuteActionResponse = Pipeline;

// @public
export interface PipelinesGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type PipelinesGetResponse = Pipeline;

// @public
export interface PipelinesListByResourceGroupNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type PipelinesListByResourceGroupNextResponse = PipelinesListResult;

// @public
export interface PipelinesListByResourceGroupOptionalParams extends coreClient.OperationOptions {
}

// @public
export type PipelinesListByResourceGroupResponse = PipelinesListResult;

// @public
export interface PipelinesListBySubscriptionNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type PipelinesListBySubscriptionNextResponse = PipelinesListResult;

// @public
export interface PipelinesListBySubscriptionOptionalParams extends coreClient.OperationOptions {
}

// @public
export type PipelinesListBySubscriptionResponse = PipelinesListResult;

// @public
export interface PipelinesListResult {
    nextLink?: string;
    value?: Pipeline[];
}

// @public
export interface PipelinesPatch {
    identity?: ManagedServiceIdentity;
    properties?: PipelinesPatchProperties;
    tags?: {
        [propertyName: string]: string;
    };
}

// @public
export interface PipelinesPatchProperties {
    connections?: PipelineConnection[];
    flowTypes?: FlowType[];
}

// @public
export interface PipelinesRejectConnectionHeaders {
    location?: string;
}

// @public
export interface PipelinesRejectConnectionOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type PipelinesRejectConnectionResponse = Connection;

// @public
export type PipelineStatus = string;

// @public
export interface PipelinesUpdateHeaders {
    location?: string;
}

// @public
export interface PipelinesUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type PipelinesUpdateResponse = Pipeline;

// @public
export interface Plan {
    name: string;
    product: string;
    promotionCode?: string;
    publisher: string;
    version?: string;
}

// @public
export type ProvisioningState = string;

// @public
export interface Resource {
    readonly id?: string;
    readonly name?: string;
    readonly systemData?: SystemData;
    readonly type?: string;
}

// @public
export interface ResourceBody {
    id: string;
    statusReason?: string;
}

// @public
export interface Schema {
    connectionId?: string;
    content?: string;
    direction?: SchemaDirection;
    id?: string;
    name?: string;
    schemaType?: SchemaType;
    schemaUri?: string;
    status?: SchemaStatus;
}

// @public
export type SchemaDirection = string;

// @public
export interface SchemasListResult {
    value?: Schema[];
}

// @public
export type SchemaStatus = string;

// @public
export type SchemaType = string;

// @public
export interface SelectedResource {
    id: string;
    location?: string;
    name?: string;
    subscriptionName?: string;
}

// @public
export interface SetDestinationEndpointPorts {
    ports?: number[];
}

// @public
export interface SetDestinationEndpoints {
    endpoints?: string[];
}

// @public
export interface SetSourceAddresses {
    values?: string[];
}

// @public
export interface SetStreamPassphrase {
    value?: string;
}

// @public
export type Status = string;

// @public
export type StreamProtocol = string;

// @public
export interface StreamSourceAddresses {
    sourceAddresses?: string[];
}

// @public (undocumented)
export interface Subscriber {
    email?: string;
    notifications?: number;
}

// @public
export interface SystemData {
    createdAt?: Date;
    createdBy?: string;
    createdByType?: CreatedByType;
    lastModifiedAt?: Date;
    lastModifiedBy?: string;
    lastModifiedByType?: CreatedByType;
}

// @public
export type TargetType = string;

// @public
export interface TrackedResource extends Resource {
    location: string;
    tags?: {
        [propertyName: string]: string;
    };
}

// @public
export interface UserAssignedIdentity {
    readonly clientId?: string;
    readonly principalId?: string;
}

// @public
export interface ValidateSchemaResult {
    message?: string;
    status?: ValidateSchemaStatus;
}

// @public
export type ValidateSchemaStatus = string;

// (No @packageDocumentation comment for this package)

```
